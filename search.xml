<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>XML开发技术——第一章</title>
    <url>/2020/11/14/XML%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
    <content><![CDATA[<p>可能你还不了解XML，只是听说课水分高就报了(<del>我也是</del>)，那就跟着我的笔记，来一起了解XML吧！</p>
<p>本系列笔记适合读过课本后过来进行总结，所以还是要先预习啊(<del>双关</del>)</p>
<p><code>注：这系列的笔记将多采用Q E C形式，即 Question Evidence Conclusion 的形式</code> </p>
<a id="more"></a>

<h1 id="XML基础知识"><a href="#XML基础知识" class="headerlink" title="XML基础知识"></a>XML基础知识</h1><h2 id="1-1-XML及其相关技术概述"><a href="#1-1-XML及其相关技术概述" class="headerlink" title="1.1 XML及其相关技术概述"></a>1.1 XML及其相关技术概述</h2><p>Q1：什么是XML？</p>
<p>C1：XML(eXtensible Markup Language)，即<strong>可扩展性标记语言</strong>，是标记语言中的一种。</p>
<p>Q2：什么是标记？</p>
<p>C2：标记是指计算机所能理解的信息符号，通过标记，计算机之间可以相互表示包含各种信息的文档。</p>
<h3 id="1-1-1-XML的发展史"><a href="#1-1-1-XML的发展史" class="headerlink" title="1.1.1 XML的发展史"></a>1.1.1 XML的发展史</h3><p>Q3：标记语言(ML)的发展过程是什么？</p>
<p>C3：</p>
<ol>
<li>SGML，它是XML的前身，由三部分构成，即语法定义、文件类型定义DTD和文件实例。但由于它<strong>过于庞大复杂，难以理解学习</strong>，真正大行其道的是其子集，如HTML和XML。</li>
<li>HTML，它是SGML的一种实际应用，其DTD作为标准被固定下来。因此，<strong>HTML的功能单一，只能用于编写网页</strong>。</li>
<li>XML，它是一套使用上规则严谨，但是语法简单的信息描述语言。它的目的是以一种更中立的方式，让用户自行决定要如何理解、呈现从服务端所提供的信息，<strong>而着重表示数据以及数据之间的联系。</strong></li>
</ol>
<h3 id="1-1-2-XML的特点"><a href="#1-1-2-XML的特点" class="headerlink" title="1.1.2  XML的特点"></a>1.1.2  XML的特点</h3><p>Q4：XML的特点主要包含什么？</p>
<p>C4：主要包含四个方面：</p>
<ol>
<li><strong>可扩展性</strong>：XML允许使用者<strong>创建和使用他们自己的标记</strong>，而不是HTML的有限词汇表。</li>
<li><strong>灵活性</strong>：XML提供了一种<strong>结构化的数据表示方式</strong>，使得用户界面分离于结构化数据，使得Web用户所追求的许多先进功能在XML环境下更容易实现。</li>
<li><strong>自描述性</strong>：XML文档通常包含一个文档类型声明，<strong>不仅人能读懂，计算机也能处理</strong>，XML表示数据的方式真正做到了独立于应用系统，并且数据能够重用。</li>
</ol>
<p>示例文档</p>
<p><img src="%E7%A4%BA%E4%BE%8B.png"></p>
<ol start="4">
<li><strong>简洁性</strong>：XML比完整的SGML简单得多，<strong>易学、易用并且以实现</strong>。</li>
</ol>
<p>XML文档包含三个不同的组成部分：</p>
<ol>
<li><p>数据内容：即文档本身（<strong>对应XML</strong>）</p>
</li>
<li><p>结构：文档类型及其元素的组织形式，文档包括何种类型的元素，以及他们的排列次序（<strong>对应DTD/SCHEMA</strong>)</p>
</li>
<li><p>表现形式：在一张纸上、浏览器屏幕上向读者描述数据的方法，还有对每种元素类型使用何种字体等。(<strong>对应XSL/CSS</strong>)</p>
</li>
</ol>
<p><img src="%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86.png"></p>
<h3 id="1-1-3-XML的实际应用"><a href="#1-1-3-XML的实际应用" class="headerlink" title="1.1.3 XML的实际应用"></a>1.1.3 XML的实际应用</h3><p>XML 成为一种<strong>与平台无关</strong>的、<strong>数据表示</strong>和<strong>数据交换</strong>的载体。</p>
<h2 id="1-2-XML规范及XML文档分类"><a href="#1-2-XML规范及XML文档分类" class="headerlink" title="1.2 XML规范及XML文档分类"></a>1.2 XML规范及XML文档分类</h2><p>XML文档实际上是一个文本文件，但并不是任何文本文件都是正确的XML文档，W3C的XML1.0规范对XML文档的语法格式进行了严格的定义。</p>
<h3 id="1-2-1-XML文档中的XML声明"><a href="#1-2-1-XML文档中的XML声明" class="headerlink" title="1.2.1 XML文档中的XML声明"></a>1.2.1 XML文档中的XML声明</h3><p>Q5：声明有哪些特点和注意事项？</p>
<p>E5：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;</span></span><br></pre></td></tr></table></figure>

<p>C5：</p>
<p>XML声明部分<strong>本身是可选的</strong>（可以没有声明）。但如果包含声明部分，必须是整个XML文档的第一行内容（<strong>第一行不能为注释或空行</strong>）。&lt;?xml要顶格，且中间无空格。</p>
<p>完整的 XML 声明包括三个部分：</p>
<p>(1) 版本声明 (<strong>version</strong>)通常情况下为1.0，<strong>在声明中是必须的</strong>，并且必须为作为<strong>第一个属性</strong>出现。</p>
<p>(2) 编码声明 (<strong>encoding</strong>)该属性的取值用于指明当前XML文档中所使用的符号的编码方式。一般采用”UTF-8”,这个属性是<strong>可选</strong>的（默认为UTF-8)。</p>
<p>注：<strong>这个编码方式与XML在文档在系统中保存时使用的编码方式没有直接关系</strong>。</p>
<p>(3) 文档独立性声明 (<strong>standalone</strong>)该属性的取值表明当前XML文件是否独立使用、还是与其他标记文件配套使用。若为“yes”,则解析当前XML文档时无需其他的外部标记声明文件。若为”no“，则可能需要使用外部的标记声明文件。这个属性是<strong>可选</strong>的。</p>
<p><img src="%E7%8B%AC%E7%AB%8B%E6%80%A7.png"></p>
<p>示例中，no的原因是因为该文档引用了外部1.ent中定义的实体：*&amp;nbsp*</p>
<p>而<strong>如果存在外部标记声明</strong>，且没有standalone声明，则解析器将认为<strong>standalone的值为no</strong></p>
<p>如果有encoding 属性和standalone属性，那么<strong>encoding属性必须放standalone属性前面</strong>。</p>
<h3 id="1-2-2-处理指令和注释"><a href="#1-2-2-处理指令和注释" class="headerlink" title="1.2.2 处理指令和注释"></a>1.2.2 处理指令和注释</h3><p>Q6：什么是处理指令？</p>
<p>E6：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml-stylesheet href=&quot;style.xsl&quot; type=&quot;text/xsl&quot;?&gt;</span></span><br></pre></td></tr></table></figure>

<p>C6：处理指令是表示将XML文档用于特殊的应用程序时表示需要执行的特定操作，而XML解析器不会执行特定的操作。</p>
<p>语法格式：<code>&lt;? target-name data ?&gt;</code></p>
<p>其中，**<?和?>表示处理指令的开始与结束<strong>；target-name表示该处理指令的</strong>名称<strong>，data部分描述该指令的</strong>具体内容**。E6的含义为：当XSL的执行引擎碰到这个处理指令时，将会根据href的取值获得指定的xsl文件，并对输入的xml文档进行相应的转换。</p>
<p>Q7：注释的注意事项是什么？</p>
<p>C7：语法格式 <code>&lt;!--......--&gt;</code>,与HTML一致。</p>
<p>​        在注释的内容中，<strong>不应该出现两个连续的横线</strong>。</p>
<p>​        注释不应该出现在元素的标记中，<strong>注释之中不应该嵌套注释</strong>。</p>
<h3 id="1-2-3-XML文档中的元素和属性"><a href="#1-2-3-XML文档中的元素和属性" class="headerlink" title="1.2.3 XML文档中的元素和属性"></a>1.2.3 XML文档中的元素和属性</h3><p>Q8：什么是元素？</p>
<p>E8：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">element_name</span> <span class="attr">att1</span>=<span class="string">&quot;val1&quot;</span> <span class="attr">att2</span>=<span class="string">&quot;val2&quot;</span>&gt;</span></span><br><span class="line">    ...content...</span><br><span class="line"><span class="tag">&lt;/<span class="name">element_name</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>C8：元素是最基本的组成单元，在元素的开始标记中还可以包含相关的属性。元素中可以包含文本、子元素、或者两者的组合。可以存在空元素，即<strong>不包含任何内容</strong>的元素，但它<strong>可以包含属性</strong>：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">details</span>&gt;</span><span class="tag">&lt;/<span class="name">details</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">details</span>/&gt;</span><span class="comment">&lt;!--上述两种空元素是等价的--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">details</span> <span class="attr">about</span>=<span class="string">&quot;Location&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">details</span>&gt;</span><span class="comment">&lt;!--空元素可以包含属性--&gt;</span></span><br></pre></td></tr></table></figure>

<p>一个元素可以包含任意多个子元素，<strong>可以包含多个同名的子元素</strong>；子元素的<strong>顺序非常重要</strong>。</p>
<p>Q9：什么是属性？</p>
<p>E9：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">author</span> <span class="attr">firstname</span>=<span class="string">&quot;Tom&quot;</span> <span class="attr">lastname</span>=<span class="string">&quot;hanks&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>C9：<strong>属性不能独立于元素而存在</strong>，通常以名-值对的形式出现，用于描述当前元素的某个方面的特征。</p>
<p>​        <strong>属性的取值必须加上引号（单引号或者双引号）</strong></p>
<p>元素在其开始标记中可以包含任意多个属性，但<strong>不能包含同名的属性</strong>。</p>
<p>对于一个元素所有的属性，<strong>它们不分先后顺序</strong>，因为它们之间可以通过名称相互区别。</p>
<p>Q10：如何命名元素和属性？</p>
<p>E10：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">example-one</span>/&gt;</span> <span class="tag">&lt;<span class="name">_example2</span>/&gt;</span> <span class="tag">&lt;<span class="name">:Example.Three</span>/&gt;</span> <span class="comment">&lt;!--这些标记名称都是正确的--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bad*character</span>/&gt;</span> <span class="tag">&lt;<span class="name">illegal</span> <span class="attr">space</span>/&gt;</span> <span class="tag">&lt;<span class="name">12number-start</span>/&gt;</span><span class="comment">&lt;!--这些都是错误的--&gt;</span></span><br></pre></td></tr></table></figure>

<p>C10：</p>
<ol>
<li>名称的开头必须以<strong>字母、下划线或者冒号</strong>开头。</li>
<li>除开头之外的其他部分可以是字母、数字、<strong>横线(-)**、下划线、</strong>点号(.)、冒号**的任意组合。</li>
<li><strong>元素名称分大小写</strong>。</li>
<li>元素和属性的名称长度没有限制。</li>
<li>可以使用非英文的元素名。</li>
</ol>
<p>Q11：如何选择子元素和属性的使用？</p>
<p>C11：</p>
<ol>
<li>对于简单的标量数据（<strong>无结构的数据</strong>），可以采用属性，否则应该采用子元素。</li>
<li>对于可能在<strong>数目上发生变化的特性</strong>，应该使用子元素，比如某本书籍可能有多个作者。</li>
</ol>
<h3 id="1-2-4-XML文档中的文本内容和CDATA段"><a href="#1-2-4-XML文档中的文本内容和CDATA段" class="headerlink" title="1.2.4 XML文档中的文本内容和CDATA段"></a>1.2.4 XML文档中的文本内容和CDATA段</h3><p>在文本内容中，一些符号会产生歧义，使得解析器不能正确辨识。比如</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;lessthan&gt;one&lt;two&lt;/lessthan&gt; &lt;!--文本中的小于号产生了歧义--&gt;</span><br></pre></td></tr></table></figure>

<p>XML 1.0 规范中定义了五种预定义实体：而<strong>除此以外的的其他实体，必须在使用前进行声明</strong>。</p>
<p><img src="%E9%A2%84%E5%AE%9A%E4%B9%89%E5%AE%9E%E4%BD%93.png"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">lessthan</span>&gt;</span>one <span class="symbol">&amp;it;</span>two<span class="tag">&lt;/<span class="name">lessthan</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注：预定义实体<strong>以&amp;表示实体的开始</strong>，<strong>最后有一个分号</strong>表示实体的结束，容易遗漏，特别注意 </p>
<p>Q12：什么是CDATA段？</p>
<p>E12：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">customer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>&lt;![CDATA[YOU &amp; ME,&lt;Tom&gt;&amp;&lt;Jerry&gt;]]&gt;<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">customer</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>C12: 假设XML文档的某块文本内容中<strong>包含大量的特殊字符</strong>，那么可以将整个文本块的内容放入到一个CDATA段中</p>
<p>即：<code>&lt;![CDATA[]]&gt;</code></p>
<p>使用 CDATA 段，可以告诉<strong>解析器不要试图从该文本块中查找 XML 标记</strong>，<strong>它仅仅就是文本内容</strong>，从而避免了歧义的产生，因此<strong>可以使用非法字符</strong>。</p>
<p>同理，CDATA段的文本内容中<strong>不能直接出现]]&gt;**，并且CDATA段</strong>不应该嵌套使用**。（与注释类似）</p>
<p>Q13：什么是空白字符？</p>
<p>C13：XML文档中的空白字符包括空格、回车、换行、制表等四种符号。</p>
<p>注：在<strong>缺省</strong>的情况下，对于连续出现的空白字符，解析器会将其<strong>缩减为一个空格字符</strong>。如果准备<strong>显示标记包含的全部空格</strong>，在编辑xml文件时将输入法换成<strong>“中文”输入法</strong>，并选择“<strong>全角状态”来编辑空格字符</strong>。</p>
<h3 id="1-2-5-XML文档的良构性规则"><a href="#1-2-5-XML文档的良构性规则" class="headerlink" title="1.2.5 XML文档的良构性规则"></a>1.2.5 XML文档的良构性规则</h3><p>Q14：良构的XML文档要满足什么要求？</p>
<p>C14:</p>
<ol>
<li>开始标记必须与结束标记相对应。</li>
<li>标记是大小写敏感的。</li>
<li>标记必须正确的嵌套。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">book</span>&gt;</span><span class="tag">&lt;<span class="name">author</span>&gt;</span>tom hanks<span class="tag">&lt;/<span class="name">book</span>&gt;</span><span class="tag">&lt;/<span class="name">author</span>&gt;</span> <span class="comment">&lt;!--这是错误的--&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>属性值必须使用引号括起来：</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">details</span> <span class="attr">about</span>=<span class="string">Location/</span>&gt;</span> <span class="comment">&lt;!--不加引号是错误的，可加单引号或双引号--&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>有且只有一个根元素。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">author</span>&gt;</span>tom hanks<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">author</span>&gt;</span>mike jimmy<span class="tag">&lt;/<span class="name">author</span>&gt;</span><span class="comment">&lt;!--这段内容称为XML片段--&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="1-2-6-XML文档的分类"><a href="#1-2-6-XML文档的分类" class="headerlink" title="1.2.6 XML文档的分类"></a>1.2.6 XML文档的分类</h3><p>XML 既可以是<strong>面向数据</strong>（Data Centric）的，又可以是<strong>面向文档</strong>（Document Centric）的。</p>
<p>面向数据的文档主要利用 XML 来传送应用数据，这些文档包括销售订单（参见 data-centric.xml）、病人记录和科学数据等。</p>
<p>面向数据的 XML 文档的物理结构，如元素的顺序、或者数据被存储为属性还是子元素，通常不是很重要。它们的特征是高度有序的结构，并且同时带有那些数据结构的多个项目，类似于关系数据库系统中的多条记录。 </p>
<p>面向文档的 XML 文件几乎没有结构，元素结构粗糙。面向文档的文档是利用 XML 来获取自然（人类）语言的那些文档，如留言信息（参见 doc-centric.xml）、用户手册。 </p>
<p>它们以复杂或无规则的结构和混合内容为特征，而且文档的物理结构非常重要。这些文档的处理侧重于给用户提供信息的最终表示，因此它们也被称作面向表示的文档。 </p>
<h2 id="1-3-命名空间"><a href="#1-3-命名空间" class="headerlink" title="1.3 命名空间"></a>1.3 命名空间</h2><p>Q15：什么是命名空间？</p>
<p>C15：命名空间 (namespace) 主要是通过某种形式来表示标识符 (identifier) 的上下文，可以将逻辑上相关的标识符组织成相应的命名空间，可使整个系统更加模块化。 </p>
<h3 id="1-3-2-XML中命名空间的声明和使用"><a href="#1-3-2-XML中命名空间的声明和使用" class="headerlink" title="1.3.2 XML中命名空间的声明和使用"></a>1.3.2 XML中命名空间的声明和使用</h3><p>Q16：如何声明命名空间？</p>
<p>E16：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">myns:element</span> <span class="attr">xmlns:myns</span>=<span class="string">&quot;http://www.myns.com&quot;</span>&gt;</span></span><br><span class="line">    .....</span><br><span class="line"><span class="tag">&lt;/<span class="name">myns:element</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>C16：声明XML命名空间的语法为：<strong>xmlns:prefix-name=”URI”**。其中，</strong>xmlns是XML的保留属性，用来声明命名空间<strong>。命名空间的前缀名称是以字母或下划线（_）开头的、</strong>不包含空白字符和冒号（:）<strong>的字符串，通常规定</strong>不应该使用 XML 中的保留字**，比如 xml、xsl 等等。</p>
<p>对于例子，myns:element表示element元素属于myns这个命名空间，而myns只是命名空间的简称，后面的语句才是命名空间的声明，表示myns命名空间的全程为字符串”<a href="http://www.myns.com&quot;./">http://www.myns.com&quot;。</a></p>
<p>Q17：为什么不建议用简短的字符串作为命名空间的全称？</p>
<p>C17：为了减少不同命名空间标识符冲突的可能性。</p>
<p>Q18：怎样使用缺省命名空间？</p>
<p>E18：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">company</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.myns.com&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">company-info</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>SoftwareBG<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">fdate</span>&gt;</span>2007-03-17<span class="tag">&lt;/<span class="name">fdate</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">ns1:division</span> <span class="attr">xmlns:ns1</span>=<span class="string">&quot;http://www.myns.com/division&quot;</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">ns1:name</span>&gt;</span>Development<span class="tag">&lt;/<span class="name">ns1:name</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">ns1:employees</span>&gt;</span>100<span class="tag">&lt;/<span class="name">ns1:employees</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">ns1:division</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">company-info</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">company</span>&gt;</span> </span><br></pre></td></tr></table></figure>

<p>C18：由例子：根元素company的<strong>开始标记中声明了一个无前缀名的命名空间，它的作用范围为整个XML文档</strong>。因此在该文档中，<strong>任何没有显示地指定命名空间的元素和属性</strong>（即除了disivion命名空间下的其他），都属于这个缺省的无名命名空间。</p>
<p>教学要求：能较系统地了解XML及其相关技术概述，XML在各个领域方面的应用，XML规范及XML文档分类，命名空间，XML数据模型规范等；</p>
<h2 id="1-4-XML文档的数据模型规范"><a href="#1-4-XML文档的数据模型规范" class="headerlink" title="1.4 XML文档的数据模型规范"></a>1.4 XML文档的数据模型规范</h2><p>以下片段都将转化为<code>&lt;a b=&#39;upcase&#39;&gt; Hello! &lt;/a&gt;</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">b</span>=<span class="string">&#x27;upcase&#x27;</span>&gt;</span> <span class="tag">&lt;<span class="name">[CDATA[Hello!]]</span>&gt;</span> <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">b</span>=<span class="string">&#x27;upcase&#x27;</span>&gt;</span> Hello&amp;#33 <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="结"><a href="#结" class="headerlink" title="结"></a>结</h1><p>XML第一章的内容都属于基础，比较简单，多考于选择题，因此需要广覆盖知识点，不要在这里失分。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>XML</tag>
      </tags>
  </entry>
  <entry>
    <title>XML开发技术——第五章</title>
    <url>/2020/11/25/XML%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%AC%E4%BA%94%E7%AB%A0/</url>
    <content><![CDATA[<p>经过了上一次的学习，我们学到了用于查询的XPATH，它会在之后的很多地方予以应用。</p>
<p>比如今天我们要讲的XSLT</p>
<a id="more"></a>

<h1 id="第五章-XSLT"><a href="#第五章-XSLT" class="headerlink" title="第五章 XSLT"></a>第五章 XSLT</h1><p>本章内容的学习目的：</p>
<ol>
<li>理解和掌握XML文档的转换过程。</li>
<li>学习如何使用XSLT中的模板实现XML文档的转换。</li>
<li>学习如何使用XSLT中的排序、循环、条件分支语句实现各种处理。</li>
<li>创建使用参数和变量的XSLT文档。</li>
</ol>
<h2 id="5-1-XSLT"><a href="#5-1-XSLT" class="headerlink" title="5.1 XSLT"></a>5.1 XSLT</h2><p>Q1：什么是XSLT？</p>
<p>C1：XSLT(e<strong>X</strong>tensible <strong>S</strong>tylesheet <strong>L</strong>anguage <strong>Transformations</strong>)，其中的T表示“转换”，它是一种专门用于对XML树型数据进行<strong>结构重组转换</strong>的有力工具，可以根据指定的<strong>转换规则</strong>（在XSLT中称之为模板）将一个XML文档树或者其中的部分内容转换为另一种文档树形式。</p>
<p>XSLT不仅局限于结构上的重组，它可以<strong>将XML文档转换为任何形式</strong>，包括XML、HTML和普通文本。</p>
<p>XSL是它的前身,本来包含了XML数据表达和数据转换。数据转换部分从中独立出来成为XSLT。剩下的数据表达部分成为XSL-FO</p>
<p>Q2：XSLT有什么注意事项？</p>
<p>C2：</p>
<ol>
<li>XSLT语言是一种声明性的语言，即XSLT程序本身<strong>只是包含了一些转换规则的XML文档。</strong></li>
<li>XSLT处理程序（或称之为执行引擎）将首先确定 XSLT规则，然后根据规则的<strong>匹配条件</strong>（<strong>通过XPath 表达式</strong>指定）、以及优先顺序完成相应的转换操作。</li>
<li><strong>XSLT本身也是一个XML文档</strong>，所以它必须严格遵守XML规范。其根元素的命名空间为<code>http://www.w3.org/1999/XSL/Transform</code> 即：</li>
</ol>
<p><code>&lt;xsl:stylesheet version=&quot;2.0&quot; xmlns:xsl=&quot;http://www.w3.org/1999/XSL/Transform&quot;&gt;</code></p>
<h3 id="5-1-1-XSLT的工作原理"><a href="#5-1-1-XSLT的工作原理" class="headerlink" title="5.1.1 XSLT的工作原理"></a>5.1.1 XSLT的工作原理</h3><p>Q3：XSLT是怎样工作的？</p>
<p>E3：<img src="%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png"></p>
<p>C3：</p>
<ol>
<li>在进行XSLT的转换任务时，需要<strong>两个输入文档</strong>，一个是包含源数据的<strong>XML文档</strong>，一个是包含转换任务规则的<strong>XSLT文档</strong>。</li>
<li>由XML解析器对这两个文档进行解析，将XML文档转换为所对应的文档树结构，<strong>将xslt(xsl)文档看作是一系列的转换规则</strong>。</li>
<li><strong>由XSLT引擎调用这些规则</strong>，对文档树进行遍历，分别处理其中指定的数据节点，将其转换为所需的结果集，并序列化为结果文档。</li>
</ol>
<h3 id="5-1-2-XSLT的一个简单示例"><a href="#5-1-2-XSLT的一个简单示例" class="headerlink" title="5.1.2 XSLT的一个简单示例"></a>5.1.2 XSLT的一个简单示例</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;hello.xlst&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">message</span>&gt;</span>Hello!<span class="tag">&lt;/<span class="name">message</span>&gt;</span>       <span class="comment">&lt;!--这是hello.xsl文档--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xsl:stylesheet</span> <span class="attr">version</span>=<span class="string">&quot;2.0&quot;</span> <span class="attr">xmlns:xsl</span>=<span class="string">&quot;http://www.w3.org/1999/XSL/Transform&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- transform the input root (/) --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">xsl:template</span> <span class="attr">match</span>=<span class="string">&quot;/&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">html</span>&gt;</span> </span><br><span class="line">        		<span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line">            		<span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><br><span class="line">	        			<span class="tag">&lt;<span class="name">xsl:value-of</span> <span class="attr">select</span>=<span class="string">&quot;message&quot;</span>/&gt;</span></span><br><span class="line">					<span class="tag">&lt;/<span class="name">h1</span>&gt;</span> </span><br><span class="line">      			<span class="tag">&lt;/<span class="name">body</span>&gt;</span>    		</span><br><span class="line">			<span class="tag">&lt;/<span class="name">html</span>&gt;</span>       </span><br><span class="line">		<span class="tag">&lt;/<span class="name">xsl:template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xsl:stylesheet</span>&gt;</span>              <span class="comment">&lt;!--这是hello.xslt文档--&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="5-2-XSLT中模板的创建以及内置模板的使用"><a href="#5-2-XSLT中模板的创建以及内置模板的使用" class="headerlink" title="5.2 XSLT中模板的创建以及内置模板的使用"></a>5.2 XSLT中模板的创建以及内置模板的使用</h2><h3 id="5-2-1-XSLT中模板的声明"><a href="#5-2-1-XSLT中模板的声明" class="headerlink" title="5.2.1 XSLT中模板的声明"></a>5.2.1 XSLT中模板的声明</h3><p>Q4：怎么声明模板？</p>
<p>E4：<img src="%E6%A8%A1%E6%9D%BF%E5%A3%B0%E6%98%8E.png"></p>
<p>C4：模板标记之间的内容相当于一个<strong>函数的函数体</strong>，表示在调用该模板时应该执行的具体操作。而元素开始标记中的属性match、name、mode和priority则用于描述该模板的相关信息。</p>
<p>Q5：模板有哪些属性？</p>
<p>C5：</p>
<ol>
<li>匹配路径属性 match</li>
</ol>
<p>在XSLT中，模板的调用分为两种方式：</p>
<p><strong>●根据模板的匹配路径</strong>（在遍历的过程中）调用，具体又有两种情况：</p>
<p>i. 对于模板 xsl:template match=”/“，XSLT 处理器在碰到 XML 文档的文档节点时自动调用该模板，就好像作为<strong>程序执行的入口</strong>。</p>
<p>ii. 对于其他的模板match=other-pattern，将在模板xsl:template match=”/“的转换规则（函数体）中通过指出匹配路径的方式（使用xsl:apply-templates）进行隐式地或者显式地调用。</p>
<p>●<strong>根据模板名称属性</strong>，使用 xsl:call-template name=template-name  进行调用。 </p>
<ol start="2">
<li>名称属性 name</li>
</ol>
<p>模板&lt;xsl:template match=“/”&gt;和&lt;xsl:template match=“message”&gt;都没有具体的名称，因此将其称为<strong>无名模板</strong>。这些模板之所以没有名称，是因为<strong>它们的调用是在遍历文档树的过程中自动进行的</strong>，不需要名称。</p>
<p>也可以使用name属性为模板指定一个名称，使其成为命名模板 。例</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xsl:stylesheet</span> <span class="attr">version</span>=<span class="string">&quot;2.0&quot;</span> <span class="attr">xmlns:xsl</span>=<span class="string">&quot;http://www.w3.org/1999/XSL/Transform&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xsl:template</span> <span class="attr">match</span>=<span class="string">&quot;/&quot;</span> <span class="attr">name</span>=<span class="string">&quot;one&quot;</span>&gt;</span>              <span class="comment">&lt;!--命名模板 one--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">xsl:call-template</span> <span class="attr">name</span>=<span class="string">&quot;another&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">xsl:template</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">xsl:template</span> <span class="attr">name</span>=<span class="string">&quot;another&quot;</span>&gt;</span>                    <span class="comment">&lt;!--命名模板 another--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">output</span>&gt;</span>Simple output<span class="tag">&lt;/<span class="name">output</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">xsl:template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xsl:stylesheet</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>XSLT 处理器将调用命名模板 one（实际上名称 one 没有作用，因为是自动调用的），然后<strong>在模板 one 中使用 xsl:call-template 直接调用名为 another 的模板</strong>，在模板 another 执行结束之后，继续执行模板 one 的后续指令，<strong>这个过程非常类似于函数的调用</strong>。 </p>
<ol start="3">
<li>模式属性 mode</li>
</ol>
<p><img src="mode.png"></p>
<ol start="4">
<li>优先级属性 priority</li>
</ol>
<p><img src="%E4%BC%98%E5%85%88%E7%BA%A7.png"></p>
<p>注意：XSLT中<strong>允许存在同名的模板</strong>；</p>
<p>当没有priority属性时，将执行<strong>后声明的模板</strong>；</p>
<p>有priority属性时，将使用 <strong>priority取值较大</strong>的模板。 </p>
<ol start="5">
<li>返回类型属性 as</li>
</ol>
<p>模板返回类型属性as的取值，表示<strong>该模板应该返回的数据类型</strong>。</p>
<p><img src="as.png"></p>
<p>注：该返回的XML元素<strong>包含了子元素和文本内容</strong>。</p>
<p>模板的返回类型属性<strong>as是一个可选的参数</strong>，如果不指定该参数，则模块可以<strong>输出任意的文本内容</strong>。</p>
<h3 id="5-2-1-XSLT中模板的调用"><a href="#5-2-1-XSLT中模板的调用" class="headerlink" title="5.2.1 XSLT中模板的调用"></a>5.2.1 XSLT中模板的调用</h3><h4 id="1-使用xsl-apply-templates-调用模板"><a href="#1-使用xsl-apply-templates-调用模板" class="headerlink" title="1.使用xsl:apply-templates 调用模板"></a>1.使用xsl:apply-templates 调用模板</h4><p>调用顺序：在<strong>广度优先</strong>、逐层向下的遍历过程中，指定继续遍历<strong>当前节点的所有子节点</strong></p>
<p>完整语法：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;xsl:apply-templates select=Expression mode=QName&gt;</span><br><span class="line">        ......</span><br><span class="line">&lt;/xsl:apply-templates&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于xsl:apply-templates元素，<strong>select和mode属性都是可选的</strong>，即可以直接使用<code>&lt;xsl:apply-templates/&gt;</code></p>
<p><img src="%E6%A8%A1%E6%9D%BF1.png"></p>
<p>对于上例，XSLT自动调用模板1，开始对整个XML文档树的遍历，即依次调用“处理指令”、“message元素”所对应的模板。所以模板1中使用了<code>&lt;xsl:apply-templates/&gt;</code>，表示<strong>调用当前节点的所有子节点所对应的模板</strong>。若模板1中无<code>&lt;xsl:apply-templates/&gt;</code>，<strong>遍历过程将中断</strong>，不会处理除文档节点”/“之外的任何节点。</p>
<p>下面介绍该元素的两个属性</p>
<ol>
<li>select(<strong>取值为一个XPath表达式</strong>）允许指定<strong>仅遍历当前节点的哪些子节点</strong>（以调用相应的模板）</li>
</ol>
<p>例：<code>&lt;xsl:apply-templates select=&quot;message&quot;/&gt;</code>仅调用“message元素”所对应的模板</p>
<ol start="2">
<li>mode属性指定需要在match属性取值相同的模板中，选择哪一个进行调用。</li>
</ol>
<p><img src="mode2.png"></p>
<h4 id="2-使用xsl-call-template-调用模板"><a href="#2-使用xsl-call-template-调用模板" class="headerlink" title="2.使用xsl:call-template 调用模板"></a>2.使用xsl:call-template 调用模板</h4><p>在xsl:template元素开始标记和结束标记之间，使用 xsl:param元素为所在的模板声明参数，其as属性可以指定参数的数据类型。 例</p>
<p><img src="%E5%8F%82%E6%95%B0.png"></p>
<p>注：用于为模板声明参数的<strong>xsl:param元素必须出现在模板正文的前面</strong></p>
<p>​        在模板正文中，使用**$+’模板参数名’**来引用模板参数，以避免将其作为字符串进行处理。</p>
<h3 id="5-2-2-XSLT中的内置模板"><a href="#5-2-2-XSLT中的内置模板" class="headerlink" title="5.2.2 XSLT中的内置模板"></a>5.2.2 XSLT中的内置模板</h3><p>Q6：怎样分析内置模板？</p>
<p>E6：<img src="%E5%86%85%E7%BD%AE%E6%A8%A1%E6%9D%BF.png"></p>
<p>C6：模板1’的<code>match=“*|/”</code>是用于处理文档节点和所有元素节点（使用了通配符*），该模板的任务是调用所有子节点的处理模板。</p>
<p>​        模板2‘的<code>match=“text()|@*”,</code>表示它用于处理文本节点和所有属性节点（使用了通配符@*），由于文本节点和属性节点不可能再包含子节点，所以这个模板的任务是直接打印出当前节点（文本节点和属性节点）的内容(<strong>&lt;xsl:value-of select=”.”/&gt;</strong>)</p>
<p>Q7：内置模板有什么作用？</p>
<p>C7：内置模板中仅对<strong>文本节点和属性节点</strong>进行了处理，即输出了其文本内容。其作用在于：让我们<strong>集中精力编写相关节点的处理模板，而无需过多地操心整个遍历过程中模板的逐层调用</strong>。只有在用户没有自定义处理某个节点的模块规则时，才会调用内置模块中的规则；否则，<strong>用户自定义的模块规则将覆盖内置模块中的规则</strong>。</p>
<p>Q8：内置模板存在什么问题？</p>
<p>E8：</p>
<p><img src="%E9%94%99%E8%AF%AFXML.png"></p>
<p><img src="%E6%A8%A1%E6%9D%BF%E9%94%99%E8%AF%AF.png"></p>
<p><img src="%E9%94%99%E8%AF%AF%E8%A7%A3%E7%AD%94.png"></p>
<p>C8：在Company模板中，<code>&lt;xsl:apply-templates/&gt;</code>将调用其子节点(Name和Person)的处理模板。但这时<strong>不存在match=“Name”的模板</strong>（修改错误时则只需要加上空模板Name即可），于是调用默认模板（先1后2），<strong>输出了文本节点的内容</strong>，导致文本节点的内容输出了两次，而Person的子元素Name没有出现两次。</p>
<h2 id="5-3-XSLT模板中各种转换功能的实现"><a href="#5-3-XSLT模板中各种转换功能的实现" class="headerlink" title="5.3 XSLT模板中各种转换功能的实现"></a>5.3 XSLT模板中各种转换功能的实现</h2><h3 id="5-3-1-value-of-text"><a href="#5-3-1-value-of-text" class="headerlink" title="5.3.1 value-of   text"></a>5.3.1 value-of   text</h3><p>Q9：如何使用value-of？</p>
<p>E9：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">message</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">subject</span>&gt;</span>I<span class="tag">&lt;/<span class="name">subject</span>&gt;</span><span class="tag">&lt;<span class="name">predicate</span>&gt;</span>Love<span class="tag">&lt;/<span class="name">predicate</span>&gt;</span><span class="tag">&lt;<span class="name">object</span>&gt;</span>You<span class="tag">&lt;/<span class="name">object</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">message</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">xsl:value-of</span> <span class="attr">select</span>=<span class="string">&quot;.&quot;</span>/&gt;</span>   <span class="comment">&lt;!--会输出ILoveYou--&gt;</span></span><br></pre></td></tr></table></figure>

<p>C9：对于文本节点和属性节点，xsl:value-of select=“.” 当然提取的是文本节点的内容和属性节点的取值；对元素节点使用 &lt;xsl:value-of select=“.”/&gt;，那么将得到元素节点的 String-Value,如上例。</p>
<p>Q10：如何输出空格？</p>
<p>E10：<img src="text%E7%A9%BA%E7%99%BD%E5%AD%97%E7%AC%A6.png"></p>
<p>C10：此时应该使用<code>&lt;xsl:text&gt;&lt;xsl:text/&gt;</code>。xsl:text元素开始标记和结束标记<strong>之间的内容会原封不动的输出到结果中</strong>，但是其中不能包含其他XML的标记。</p>
<h3 id="5-3-2-xsl-for-each-xsl-sort"><a href="#5-3-2-xsl-for-each-xsl-sort" class="headerlink" title="5.3.2 xsl:for-each xsl:sort"></a>5.3.2 xsl:for-each xsl:sort</h3><p>Q11：怎么使用<strong>for-each与sort</strong>？</p>
<p>E11：</p>
<table><tr>
<td><img src="E:\myblog\Procrastination\source\_posts\XML开发技术——第五章\for-each.jpg" border=0></td>
<td><img src="E:\myblog\Procrastination\source\_posts\XML开发技术——第五章\结果.jpg" border=0></td>
</tr>
</table>

<p>C11：例中选择出了所有person的子元素Name，并将它们进行排序，随后进行输出。</p>
<p>关于sort的语法：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;xsl:sort select=expression </span><br><span class="line">          data-type=&#123;&quot;text&quot;|&quot;number&quot;|QName&#125; </span><br><span class="line">          order=&#123;&quot;ascending&quot;|&quot;descending&quot;&#125; </span><br><span class="line">          case-order=&#123;&quot;upper-first&quot;|&quot;lower-first&quot;&#125;/&gt;</span><br></pre></td></tr></table></figure>

<h3 id="5-3-3-xsl-if"><a href="#5-3-3-xsl-if" class="headerlink" title="5.3.3 xsl:if"></a>5.3.3 xsl:if</h3><p>Q12：怎么使用if？</p>
<p>E12：</p>
<table><tr>
<td><img src="if.jpg" border=0></td>
<td><img src="if2.jpg" border=0></td>
</tr>
</table>

<p>C12：if通常与for-each搭配，根据条件输出所需要的文本或节点。</p>
<h3 id="5-3-4-xsl-choose-xsl-when-xsl-otherwise"><a href="#5-3-4-xsl-choose-xsl-when-xsl-otherwise" class="headerlink" title="5.3.4 xsl:choose xsl:when xsl:otherwise"></a>5.3.4 xsl:choose xsl:when xsl:otherwise</h3><p>E13：<img src="switch.png"></p>
<h3 id="5-3-5-在输出中创建XML节点"><a href="#5-3-5-在输出中创建XML节点" class="headerlink" title="5.3.5 在输出中创建XML节点"></a>5.3.5 在输出中创建XML节点</h3><p>Q13：如何使用<strong>copy和copy-of</strong>？</p>
<p>E13：<img src="%E5%88%9B%E5%BB%BA%E5%85%83%E7%B4%A0.png"></p>
<p>C13：在上例中，递归的使用了xsl:copy，用于复制每一个节点到结果树中。而xsl:copy-of直接在文档入口处复制了根元素和下面的整棵树（包括属性和子元素）到结果树中，二者存在以下差异：</p>
<p><img src="copy.png"></p>
<p>缺点：xsl:copy 和 xsl:copy-of 可以将当前节点从源复制到输出，但是<strong>不能根据需要生成任意的 XML 节点</strong>。</p>
<p>Q14：如何使用<strong>element</strong>？</p>
<p>E14：<img src="element.png"></p>
<p>C14：上例通过xsl:element,将源文档中的message元素<strong>改名</strong>为了new-message</p>
<p>Q15：如何使用<strong>attribute</strong>？</p>
<p>E15：<img src="att.png"></p>
<p>C15：上例先通过copy复制了一个空的message元素，随后为其添加了属性content，并将原来message的文本内容赋给了content。</p>
<p>Q16：如何使用attribute-set？</p>
<p>E16：<img src="set.png"></p>
<h3 id="5-3-6-如何控制输出格式？"><a href="#5-3-6-如何控制输出格式？" class="headerlink" title="5.3.6 如何控制输出格式？"></a>5.3.6 如何控制输出格式？</h3><p>E17：<code>&lt;xsl:output method=&quot;xml&quot; version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; indent=&quot;yes&quot;/&gt;     </code></p>
<p>C17：这表示输出为XML格式，版本为XML1.0，编码方式为UTF-8<strong>并且进行缩进</strong>，<strong>如果不进行缩进，输出的会写在同一行</strong>，难以体现出层次关系。</p>
<h1 id="结"><a href="#结" class="headerlink" title="结"></a>结</h1><p>通过本次学习，我们学习到了XSLT的基本语法和其转换方式，在考试中<strong>XSLT常考于大题中</strong>，即给出原来的XML和XSLT让你<strong>写出转换后的XML文档</strong>。需要仔细学习规则，不然会失分很多。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>XML</tag>
      </tags>
  </entry>
  <entry>
    <title>word2vec</title>
    <url>/2020/11/08/word2vec/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>自然语言处理</category>
      </categories>
      <tags>
        <tag>自然语言</tag>
      </tags>
  </entry>
  <entry>
    <title>序</title>
    <url>/2020/09/28/%E5%BA%8F/</url>
    <content><![CDATA[<p>很久之前就想拥有，在得知朋友尝试搭建了之后便立刻(不要脸)的索取了教程。会在这里记录一些心情和一些笔记（但愿）</p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构期中复习</title>
    <url>/2020/11/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<p>是时候面向考试复习一下数据结构了</p>
<p>本文只针对作者认为可能考到的知识点进行整理，存在不足，欢迎补充。</p>
<a id="more"></a>

<h1 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h1><h2 id="1-什么是数据结构"><a href="#1-什么是数据结构" class="headerlink" title="1.什么是数据结构"></a>1.什么是数据结构</h2><p>数据结构是相互之间存在一种或多种特定关系的数据元素的集合。</p>
<p>数据对象：即具有相同性质的数据元素的集合</p>
<p>例：英文字母数据对象：C={‘A’, ‘B’, ……, ‘Z’, ‘a’, ‘b’, ……, ‘z’}。</p>
<p>主要包括<strong>逻辑结构、存储结构</strong>和运算集合三部分。</p>
<p><strong>逻辑结构</strong>有四种：<strong>集合、线性结构、树形结构、图状结构（网状结构）</strong></p>
<p><strong>存储结构</strong>（也称为物理结构）有两种：<strong>顺序存储结构和链式存储结构</strong></p>
<p>顺序存储结构，是借助元素在存储器中的相对位置来表示数据之间逻辑关系，要求<strong>所有的元素依次放在一片连续空间中</strong>，通常借助程序设计语言的<strong>数组类型</strong>来描述。<br>链式存储结构<br>链式存储结构无需占用一整块存储空间。但为了表示结点之 间的关系， 需要给每个结点附加指针字段用于存放后继元素的储地址。所以链式结构通常借助程序设计语言<strong>指针类型</strong>来描述。</p>
<p>抽象数据类型的定义取决于数据类型的逻辑特性，<strong>与其在计算机内部如何表示和实现无关。</strong></p>
<p>两个重要特征：数据抽象性和数据封装性。</p>
<h4 id="例：试举一个数据结构的例子，叙述其逻辑结构和存储结构两方面的含义和相互关系。"><a href="#例：试举一个数据结构的例子，叙述其逻辑结构和存储结构两方面的含义和相互关系。" class="headerlink" title="例：试举一个数据结构的例子，叙述其逻辑结构和存储结构两方面的含义和相互关系。"></a>例：试举一个数据结构的例子，叙述其逻辑结构和存储结构两方面的含义和相互关系。</h4><p>答：例如有一张学生基本信息表，包括学生的学号、姓名、性别、籍贯、专业等。每个学生基本信息记录对应一个数据元素，学生记录按顺序号排列，形成了学生基本信息记录的线性序列。对于整个表来说，只有一个开始结点（它的前面无记录）和一个终端结点（它的后面无记录），其他的结点则各有一个也只有一个直接前趋和直接后继。<strong>学生记录之间的这种关系就确定了学生表的逻辑结构，即线性结构</strong>。<strong>这些学生记录在计算机中的存储表示就是存储结构。</strong>如果用连续的存储单元（如用数组表示）来存放这些记录，则称为顺序存储结构；如果存储单元不连续，而是随机存放各个记录，然后用指针进行链接，则称为链式存储结构。即相同的逻辑结构，可以对应不同的存储结构</p>
<h2 id="2-什么是算法"><a href="#2-什么是算法" class="headerlink" title="2.什么是算法"></a>2.什么是算法</h2><p>算法，简单来说就是解决问题的方法。它是规则的有限集合，是求解特定问题的过程描述、操作步骤或指令序列。</p>
<p>它具有5个重要特性：<strong>有穷性、确定性、可行性、输入、输出</strong></p>
<p><strong>算法时间复杂度的估算方法</strong>：</p>
<p>从算法中选取一种原操作(<strong>对于所研究的问题来说，该操作是基本操作</strong>)，将该操作重复执行的次数作为算法时间复杂度的衡量准则。</p>
<p><strong>时间复杂度与原操作的执行次数之和成正比。</strong></p>
<h1 id="第二章-表结构"><a href="#第二章-表结构" class="headerlink" title="第二章 表结构"></a>第二章 表结构</h1><h2 id="1-顺序表和链表"><a href="#1-顺序表和链表" class="headerlink" title="1.顺序表和链表"></a>1.顺序表和链表</h2><p>线性结构的逻辑结构特征：</p>
<p>​    (1)存在唯一的第1个数据元素；</p>
<p>　(2)存在唯一的最后1个数据元素；</p>
<p>　(3)第 i (&gt;1)个数据元素有唯一的1个前驱；</p>
<p>　(4)第 j (&lt;n)个数据元素有唯一的1个后继。</p>
<p><strong>顺序表：顺序存储结构：用位置描述逻辑关系</strong></p>
<p><strong>链表：链式存储结构：由指针描述逻辑关系</strong></p>
<p>补：链表的定义：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Type data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;Node,*LinkList;</span><br></pre></td></tr></table></figure>

<h4 id="例1：综合比较顺序表和链表"><a href="#例1：综合比较顺序表和链表" class="headerlink" title="例1：综合比较顺序表和链表"></a>例1：综合比较顺序表和链表</h4><p>答：顺序表在内存中是一段连续的存储空间， 通过头指针和偏移地址直接访问数据，访问数据的效率较高，为O（1），但是插入数据和删除数据的效率较低。<br> 链表在内存中是不连续的，通过每一个节点保存指向下一个节点的指针的方式来存储数据，访问数据的效率较低，但同时，插入数据和删除数据的效率较高。</p>
<h4 id="例2：解释链表的”头指针、头结点和首元素结点“三个概念"><a href="#例2：解释链表的”头指针、头结点和首元素结点“三个概念" class="headerlink" title="例2：解释链表的”头指针、头结点和首元素结点“三个概念"></a>例2：解释链表的”头指针、头结点和首元素结点“三个概念</h4><p>答：头指针：线性链表中第一个结点或头结点的存储地址，它是访问链表的起始点。</p>
<p>​        头结点：附加在第一个数据元素之前的结点，该结点的数据域一般为“空”、指针域存放第一个数据元素的地址。</p>
<p>​        首元素节点：链表中第一个存储着数据的节点。</p>
<h4 id="例3：给定链表的头指针L和一个正整数k。试设计一个尽可能高效的算法，用于查找链表L中倒数第k个位置上的结点。"><a href="#例3：给定链表的头指针L和一个正整数k。试设计一个尽可能高效的算法，用于查找链表L中倒数第k个位置上的结点。" class="headerlink" title="例3：给定链表的头指针L和一个正整数k。试设计一个尽可能高效的算法，用于查找链表L中倒数第k个位置上的结点。"></a>例3：给定链表的头指针L和一个正整数k。试设计一个尽可能高效的算法，用于查找链表L中倒数第k个位置上的结点。</h4><p>答：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">LinkSearch</span><span class="params">(ListList L,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k0=<span class="number">1</span>;</span><br><span class="line">    LinkList p=<span class="keyword">new</span> LinkList;</span><br><span class="line">    p=L-&gt;next;</span><br><span class="line">    LinkList q=p;</span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k0&lt;=k)++k0;</span><br><span class="line">        <span class="keyword">else</span> q=q-&gt;next;</span><br><span class="line">        </span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;<span class="comment">//时间复杂度为O(N)</span></span><br></pre></td></tr></table></figure>

<h2 id="2-栈与队列"><a href="#2-栈与队列" class="headerlink" title="2.栈与队列"></a>2.栈与队列</h2><p>我觉得期中考不了很难，鸽了（）</p>
<p>想了解的话请移步我朋友的博客：</p>
<p><a href="https://linyx.tk/2020/10/04/data-structure-study-note-1/">https://linyx.tk/2020/10/04/data-structure-study-note-1/</a></p>
<p>之后会补充（大概）</p>
<h2 id="3-递归"><a href="#3-递归" class="headerlink" title="3.递归"></a>3.递归</h2><p>递归的特点：</p>
<p>（1）出口至少有一个</p>
<p>（2）在经过有限次的递归调用后，能够导致递归出口的出现（<strong>递归算法必需具有终止递归的条件</strong>）</p>
<p>例：实现Hanoi塔问题</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hanoi</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">char</span> x,<span class="keyword">char</span> y,<span class="keyword">char</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">        move(x,<span class="number">1</span>,z);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        hanoi(n<span class="number">-1</span>,x,z,y);</span><br><span class="line">        move(x,n,z);</span><br><span class="line">        hanoi(n<span class="number">-1</span>,y,x,z);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第三章：树结构"><a href="#第三章：树结构" class="headerlink" title="第三章：树结构"></a>第三章：树结构</h1><h2 id="1-树"><a href="#1-树" class="headerlink" title="1.树"></a>1.树</h2><p>树是有n个结点的有限集合（n&gt;=0)</p>
<p>树的结点包含一个数据元素以及若干个指针</p>
<p>结点拥有子树的个数称为<strong>结点的度</strong>。</p>
<p>度=0的结点叫做<strong>叶结点</strong></p>
<p>树的度=<strong>max(结点的度)</strong></p>
<p>结点的层次：第l层结点的孩子定义为l+1层。</p>
<p><strong>树的高度（深度）=max（结点的层次）</strong></p>
<h4 id="例：-已知一棵度为k的树中，有n1个度为1的结点，n2个度为2的结点，…，nk个度为k的结点。试计算该树的叶子结点数。"><a href="#例：-已知一棵度为k的树中，有n1个度为1的结点，n2个度为2的结点，…，nk个度为k的结点。试计算该树的叶子结点数。" class="headerlink" title="例： 已知一棵度为k的树中，有n1个度为1的结点，n2个度为2的结点，…，nk个度为k的结点。试计算该树的叶子结点数。"></a>例： 已知一棵度为k的树中，有n1个度为1的结点，n2个度为2的结点，…，nk个度为k的结点。试计算该树的叶子结点数。</h4><p>答：<strong>n0=1+0<em>n1+1</em>n2+2*n3+…+(K-1)*nK</strong></p>
<h2 id="2-二叉树"><a href="#2-二叉树" class="headerlink" title="2.二叉树"></a>2.二叉树</h2><p>二叉树：每个结点至多只有两棵子树</p>
<p>即：<strong>结点的度&lt;=2的有序树</strong></p>
<p>二叉树的定义：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Type data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TNode</span> *<span class="title">Lchild</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TNode</span> *<span class="title">Rchild</span>;</span></span><br><span class="line">&#125;TNode,*Tree;</span><br></pre></td></tr></table></figure>

<p>满二叉树：一棵高度为k且具有2^k-1个结点的二叉树</p>
<p><img src="%E5%9B%BE%E7%89%871.png">（k=4)</p>
<p><strong>完全二叉树：高度为k，结点个数∈[2^(k-1),2^k-1]，且第k层结点都集中在左侧的二叉树。</strong></p>
<p><img src="%E5%9B%BE%E7%89%872.png"></p>
<h4 id="例：如果二叉树T的叶子结点数为n0，度为2的结点数为n2，则n0-n2-1。"><a href="#例：如果二叉树T的叶子结点数为n0，度为2的结点数为n2，则n0-n2-1。" class="headerlink" title="例：如果二叉树T的叶子结点数为n0，度为2的结点数为n2，则n0=n2+1。"></a>例：如果二叉树T的叶子结点数为n0，度为2的结点数为n2，则n0=n2+1。</h4><p>证明：</p>
<p>设二叉树T共有n个结点</p>
<p>度为0的结点数为n0，度为1的结点数为n1,度为2的结点数为n2，</p>
<p>T的分支数为m</p>
<p>（1）由于二叉树中所有结点的度&lt;=2,则：n=n0+n1+n2</p>
<p>（2）除根节点外，其余节点都有唯一前驱，则: n-1=m</p>
<p>（3）由于度=i（i=0，1，2）的结点具有i个分支，则：m=0+n1+2n2</p>
<p>联立上式得：n0=n2+1，证毕。</p>
<h2 id="3-二叉树的遍历"><a href="#3-二叉树的遍历" class="headerlink" title="3.二叉树的遍历"></a>3.二叉树的遍历</h2><h3 id="3-1-先序遍历"><a href="#3-1-先序遍历" class="headerlink" title="3.1 先序遍历"></a>3.1 先序遍历</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Tree T)</span><span class="comment">//递归写法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!T) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;T-&gt;data;</span><br><span class="line">    preOrder(T-&gt;Lchild);</span><br><span class="line">    preOrder(T-&gt;Rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Tree T)</span><span class="comment">//非递归写法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;Tree&gt; temp;</span><br><span class="line">    Tree p=T-&gt;Lchild;</span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;Lchild)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;p-&gt;data;</span><br><span class="line">            temp.push(p);</span><br><span class="line">            p=p-&gt;Lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;p-&gt;data;</span><br><span class="line">        <span class="keyword">while</span>(!p-&gt;Rchild)</span><br><span class="line">        &#123;</span><br><span class="line">            p=temp.top();</span><br><span class="line">            temp.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;Rchild)</span><br><span class="line">            p=p-&gt;Rchild;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="%E5%9B%BE%E7%89%873.png"></p>
<h3 id="3-2-中序遍历"><a href="#3-2-中序遍历" class="headerlink" title="3.2 中序遍历"></a>3.2 中序遍历</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(Tree T)</span><span class="comment">//递归写法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!T) <span class="keyword">return</span>;</span><br><span class="line">    InOrder(T-&gt;Lchild);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;T-&gt;data;</span><br><span class="line">    InOrder(T-&gt;Rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(Tree T)</span><span class="comment">//非递归写法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;Tree&gt; temp;</span><br><span class="line">    Tree p=T-&gt;Lchild;</span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;Lchild)</span><br><span class="line">        &#123;</span><br><span class="line">            temp.push(p);</span><br><span class="line">            p=p-&gt;Lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;p-&gt;data;</span><br><span class="line">        <span class="keyword">while</span>(!p-&gt;Rchild)</span><br><span class="line">        &#123;</span><br><span class="line">            p=temp.top();</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;p-&gt;data;</span><br><span class="line">            temp.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;Rchild)</span><br><span class="line">            p=p-&gt;Rchild;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="image-20201107151715620.png"></p>
<h3 id="3-3-后序遍历"><a href="#3-3-后序遍历" class="headerlink" title="3.3 后序遍历"></a>3.3 后序遍历</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(Tree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!T) <span class="keyword">return</span> ;</span><br><span class="line">    PostOrder(T-&gt;Lchild);</span><br><span class="line">    PostOrder(T-&gt;Rchild);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;T-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(Tree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;Tree&gt; tempL，tempR;</span><br><span class="line">    Tree p=T-&gt;Lchild;</span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;Lchild)</span><br><span class="line">        &#123;</span><br><span class="line">            tempL.push(p);</span><br><span class="line">            p=p-&gt;Lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!p-&gt;Rchild)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;p-&gt;data;</span><br><span class="line">            <span class="keyword">while</span>(tempR.top()-&gt;Rchild==p)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;tempR.top()-&gt;data;<span class="comment">//获取R栈顶部指针的数据</span></span><br><span class="line">                tempR.pop();<span class="comment">//弹出</span></span><br><span class="line">            &#125;</span><br><span class="line">            p=tempL.top();</span><br><span class="line">            tempL.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;Rchild)</span><br><span class="line">        &#123;</span><br><span class="line">            tempR.push(p);</span><br><span class="line">            p=p-&gt;Rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="image-20201107151732351.png"></p>
<h4 id="例：简述由先序序列和中序序列构造二叉树的基本操作方法"><a href="#例：简述由先序序列和中序序列构造二叉树的基本操作方法" class="headerlink" title="例：简述由先序序列和中序序列构造二叉树的基本操作方法"></a>例：简述由先序序列和中序序列构造二叉树的基本操作方法</h4><p>答：如果前序序列和中序序列都为空，那么构造一棵空树。否则</p>
<p>1、根据前序可确定根。</p>
<p>2、根据根和中序，可以确定左子树集合和右子树集合，并得到左子树中序序列和右子树中序序列。</p>
<p>3、在前序序列中划分出左子树前序序列和右子树前序序列。</p>
<p>4、根据左子树前序序列和左子树中序序列构造左子树。</p>
<p>5、根据右子树前序序列和右子树中序序列构造右子树。</p>
<h2 id="4-哈夫曼树"><a href="#4-哈夫曼树" class="headerlink" title="4.哈夫曼树"></a>4.哈夫曼树</h2><p><img src="image-20201107154325482.png"></p>
<h2 id="5-森林与二叉树的转换"><a href="#5-森林与二叉树的转换" class="headerlink" title="5.森林与二叉树的转换"></a>5.森林与二叉树的转换</h2><h3 id="5-1树转换为二叉树"><a href="#5-1树转换为二叉树" class="headerlink" title="5.1树转换为二叉树"></a>5.1树转换为二叉树</h3><p>（1）<strong>加虚线</strong> 在树的每层按从“左至右”的顺序<strong>在兄弟结点之间加虚线相连</strong><br>（2）去连线。<strong>除最左的第一个子结点</strong>外，父结点与所 其它子结点的连线都去掉<br>（3）旋转。将<strong>树顺时针旋转45°</strong>，原有的实线左斜<br>（4）整型。将旋转后树中的所有虛线改为实线，并向右斜。</p>
<img src="image-20201107155306011.png" alt="image-20201107155306011" style="zoom:67%;" />

<img src="image-20201107155341354.png" alt="image-20201107155341354" style="zoom: 67%;" />

<h3 id="5-2二叉树转换成树"><a href="#5-2二叉树转换成树" class="headerlink" title="5.2二叉树转换成树"></a>5.2二叉树转换成树</h3><p>（1）加虚线  若某结点i是其父结点的左子树的根结点，<strong>则将该结点ⅰ的右子结点以及沿右子链不断地搜索所有的右子结点，将所有这些右子结点与i结点的父结点之间加虚线相连</strong></p>
<p>（2）去连线  去掉二叉树中所有其右子结点之间的连线<br>（3）规整化  将图中各结点按层次排列且将所有的虚线变成实线</p>
<img src="image-20201107155753914.png" alt="image-20201107155753914" style="zoom: 80%;" />]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>汇编语言总复习</title>
    <url>/2020/12/26/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E6%80%BB%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<p>本文将结合老师说的考试范围与PPT，对所涉及的知识点作个人总结，面向考试复习（<del>高星，yyds</del>）</p>
<p>顺序有点乱，如果有时间会再调一下。</p>
<a id="more"></a>

<h2 id="一、子程序与主程序"><a href="#一、子程序与主程序" class="headerlink" title="一、子程序与主程序"></a>一、子程序与主程序</h2><h3 id="（一）什么是子程序"><a href="#（一）什么是子程序" class="headerlink" title="（一）什么是子程序"></a>（一）什么是子程序</h3><p>把功能相对独立的程序段单独编写和调试，作为一个相对独立的模块供程序使用，就形成子程序</p>
<p>子程序可以实现源程序的模块化，可简化源程序结构，可以提高编程效率</p>
<p><strong>参数传递是子程序设计的重点和难点</strong></p>
<p>子程序的调用和返回是由指令<strong>CALL和RET</strong>(return)来完成的</p>
<p>返回时，RET直接从当前栈顶取内容作为返回地址。因此要保证RET指令执行前堆栈栈顶的内容刚好是返回的地址。</p>
<p>例：子程序的常见格式（实现回车换行的子程序）：</p>
<p><img src="%E5%AD%90%E7%A8%8B%E5%BA%8F%E7%A4%BA%E4%BE%8B.png"></p>
<p>注意：</p>
<ol>
<li>对简化段定义格式，在tiny和small下，过程(PROC)的默认属性为near；对完整段定义格式下，过程的默认属性为near。</li>
<li>进行过程设计时，需要注意寄存器的保护和恢复，即<strong>开始时将要修改的寄存器内容压入栈，结束后再逆序弹出</strong>。</li>
</ol>
<h3 id="（二）如何进行参数传递"><a href="#（二）如何进行参数传递" class="headerlink" title="（二）如何进行参数传递"></a>（二）如何进行参数传递</h3><p>主程序在调用子程序时，通常需要提供一些数据，即<strong>入口参数（输入参数）</strong></p>
<p>子程序执行结束后要返回主程序数据，即<strong>出口参数（输出参数）</strong></p>
<p>参数的形式分为两种</p>
<p>① 数据本身（传值）②数据的地址（传址）</p>
<p>下面介绍如何传递参数</p>
<h4 id="1-寄存器传递参数（共享寄存器）"><a href="#1-寄存器传递参数（共享寄存器）" class="headerlink" title="1.寄存器传递参数（共享寄存器）"></a>1.寄存器传递参数（共享寄存器）</h4><p>把参数存于约定的寄存器中，可以传值，也可以传址。</p>
<p><img src="%E5%AF%84%E5%AD%98%E5%99%A8%E4%BC%A0%E5%8F%82.png"></p>
<p>上图的子程序将和存在了al中，返回后再将其mov到result中，实现了参数传递。</p>
<p>注:子程序对带有入口参数的寄存器可以保护，也可以不保护；上图未保护</p>
<p>​     子程序对带有出口参数的寄存器不能保护和恢复</p>
<h4 id="2-变量传递参数（共享变量）"><a href="#2-变量传递参数（共享变量）" class="headerlink" title="2.变量传递参数（共享变量）"></a>2.变量传递参数（共享变量）</h4><p>主程序和子程序直接采用同一个变量名共享同一个变量。</p>
<p>类比于C++中的加引用，<strong>直接改变了变量的值</strong>。</p>
<p><img src="%E5%8F%98%E9%87%8F%E4%BC%A0%E5%8F%821.png"></p>
<p><img src="%E5%8F%98%E9%87%8F%E4%BC%A0%E5%8F%822.png"></p>
<p>上图的子程序直接将al中的值mov到了result，随后返回到主程序。</p>
<h4 id="3-堆栈传递参数（共享堆栈）"><a href="#3-堆栈传递参数（共享堆栈）" class="headerlink" title="3.堆栈传递参数（共享堆栈）"></a>3.堆栈传递参数（共享堆栈）</h4><p>主程序将子程序的入口参数压入堆栈，子程序从堆栈中取出参数</p>
<p>子程序将出口参数压入堆栈，主程序弹出堆栈取得它们</p>
<p>前方高能</p>
<p><img src="%E5%A0%86%E6%A0%88%E4%BC%A0%E5%8F%821.png"></p>
<p>入口参数为数组的偏移地址和数组的元素个数，通过压入堆栈进行传递。</p>
<p><img src="%E5%A0%86%E6%A0%88%E4%BC%A0%E5%8F%822.png"></p>
<p>程序在保护bp后，将bp置为栈顶，并通过偏移位置来分别寻址获得压入的偏移地址和元素参数。最后按反序弹出栈内值和址。</p>
<p>上述程序堆栈的使用情况如下图</p>
<p><img src="%E5%A0%86%E6%A0%88%E6%83%85%E5%86%B5.png"></p>
<p>由于<strong>主程序压入了2个参数，使用了堆栈区的4字节</strong>，故采用上述办法平衡堆栈。</p>
<p>注：由于寄存器的保护也存于堆栈中，所以在子程序退出时<strong>要特别注意pop的顺序</strong>。</p>
<h2 id="二、缓冲区"><a href="#二、缓冲区" class="headerlink" title="二、缓冲区"></a>二、缓冲区</h2><h3 id="（一）如何定义缓冲区"><a href="#（一）如何定义缓冲区" class="headerlink" title="（一）如何定义缓冲区"></a>（一）如何定义缓冲区</h3><p>例</p>
<p><img src="%E7%BC%93%E5%86%B2%E5%8C%BA%E5%AE%9A%E4%B9%89.png"></p>
<p>该例表示在内存中申请一个<strong>缓冲区为83个字节，首地址给BUF</strong>。</p>
<p>缓冲区分为<strong>三个部分</strong></p>
<p>第一个字节内放的是<strong>事先填入最多欲接收的字符个数</strong>（包括回车字符，可以是1～255），在例中为81，表示申请的存放数据的缓冲区的字节数为81个。</p>
<p>第二个字节 ‘ ？‘表示的是实际存放的字节个数（不包括回车）</p>
<p>就是说，你放入2个字节的数据，“？”变成2，放10个字节的数据，变成10）；</p>
<p>DB表示的是分配一个或多个字节；</p>
<p><strong>输入的数据（字符串）从第三个字节开始存放</strong>，存放至第82个字节，<strong>第81个字节存放回车符（0DH）,0DH作为输入数据的结束</strong>。</p>
<p><strong>DUP(0)**表示的是</strong>存放数据的81个字节初始值全为0**，即为：81 0 0 0 0······（第82个字节）0 ODH。</p>
<p>注：实际输入的字符数多于定义数时，多出的字符丢掉，且响铃</p>
<h3 id="（二）如何使用缓冲区"><a href="#（二）如何使用缓冲区" class="headerlink" title="（二）如何使用缓冲区"></a>（二）如何使用缓冲区</h3><p>下例实现了字符串的输入</p>
<p><img src="%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BE%93%E5%85%A5.png"></p>
<h2 id="三、串操作指令"><a href="#三、串操作指令" class="headerlink" title="三、串操作指令"></a>三、串操作指令</h2><p>串操作指令的操作对象是以字（W）为单位的<strong>字串</strong>，或是以字节（B）为单位的<strong>字节串</strong></p>
<p>串操作指令采用了特殊的寻址方式</p>
<ol>
<li>源操作数用寄存器SI间接寻址，默认在数据段DS中，即DS:[DI]</li>
<li><strong>目的操作数用寄存器DI间接寻址，默认在附加段ES中</strong>，即ES:[SI]</li>
<li>每执行一次串操作，SI和DI将自动修改</li>
</ol>
<p>注：由于要自动修改SI与DI，所以用户需要在进行串操作之前<strong>改变方向标志DF先确定增加或减小的方向</strong></p>
<p>即：执行<strong>CLD</strong>（DF=0，主存地址增大，<strong>较为常用</strong>）或执行STD（DF=1，主存地址减小）</p>
<p>串操作经出<strong>配合重复前缀指令</strong>，通过<strong>计数器CX</strong>控制重复执行串操作指令的次数。</p>
<h3 id="（一）串传送指令"><a href="#（一）串传送指令" class="headerlink" title="（一）串传送指令"></a>（一）串传送指令</h3><p>①串传送 MOVSB/W（move string）</p>
<p>把字节从主存的源地址传送至目标地址</p>
<p><strong>MOVSB</strong> 字节串传送：<strong>ES:[DI]←DS:[SI]</strong></p>
<p>②串存储 STOSB/W（store string）</p>
<p>把<strong>AL或AX</strong>数据传送至目标地址</p>
<p><strong>STOSB</strong>  字节串存储：<strong>ES:[DI]←AL</strong>（AL传字节）</p>
<p><strong>STOSW</strong> 字串存储：    <strong>ES:[DI]←AX</strong>（AX传字）</p>
<p>③串读取 LODSB/W（load string）</p>
<p>把指定主存单元的数据传送给<strong>AL或AX</strong></p>
<p><strong>LODSB</strong>  字节串读取： <strong>AL←DS:[SI]</strong></p>
<p><strong>LODSW</strong> 字串读取：    <strong>AX←DS:[SI]</strong></p>
<p>④REP重复前缀指令</p>
<p><strong>REP</strong> <strong>；每执行一次串指令，CX减1直到CX＝0</strong>，重复执行结束</p>
<p>即：当数据串没有结束（CX≠0），则继续传送</p>
<h3 id="（二）串检测指令"><a href="#（二）串检测指令" class="headerlink" title="（二）串检测指令"></a>（二）串检测指令</h3><p>①串比较指令CMPS（compare string）</p>
<p>将主存中的<strong>源操作数减去至目的操作数</strong>，以便设置标志，进而比较两操作数之间的关系</p>
<p><strong>CMPSB</strong>  字节串比较：<strong>DS:[SI]－ES:[DI]</strong></p>
<p>②串扫描SCAS（scan string）</p>
<p>将<strong>AL/AX减去至目的操作数</strong>，以便设置标志，进而比较AL/AX与操作数之间的关系</p>
<p><strong>SCASB</strong>  字节串扫描：<strong>AL－ES:[DI]</strong></p>
<p><strong>SCASW</strong> 字串扫描：   <strong>AX－ES:[DI]</strong></p>
<p>③REPZ/REPE重复前缀指令</p>
<p>每执行一次串指令，CX减1并判断ZF是否为0，</p>
<p>只要CX＝0或ZF＝0，重复执行结束。</p>
<p>即：当数据串没有结束（CX≠0），<strong>并且串相等（ZF＝1），则继续比较</strong></p>
<p>④REPNZ/REPNE重复前缀指令</p>
<p>每执行一次串指令，CX减1并判断ZF是否为0，</p>
<p>只要CX＝0或ZF＝0，重复执行结束。</p>
<p>即：当数据串没有结束（CX≠0），<strong>并且串不相等（ZF＝0），则继续比较</strong></p>
<p>例：</p>
<p><img src="%E6%AF%94%E8%BE%83%E5%AD%97%E7%AC%A6%E4%B8%B2.png"></p>
<p>在上例中，指令repz cmpsb结束有两种情况</p>
<p>第一种：ZF=0，即<strong>出现不相等的字符</strong></p>
<p>第二种：CX=0，即<strong>比较完了所有字符</strong></p>
<p>注意，在这种情况下，<strong>如果ZF=0，则说明最后一个字符不相等，ZF=1才能说明两个字符串相同</strong>。</p>
<p>所以，重复比较结束后，需要通过<strong>jnz</strong>指令 来判断<strong>zf位</strong>，若其=0，则字符串不相等。</p>
<p>总流程图如下</p>
<p><img src="%E4%B8%B2%E6%93%8D%E4%BD%9C%E6%B5%81%E7%A8%8B%E5%9B%BE.png"></p>
<p>下例为SCAS在字符串中查找空格字符的用法</p>
<p><img src="%E6%9F%A5%E6%89%BE%E7%A9%BA%E6%A0%BC.png"></p>
<h2 id="四、常用DOS命令"><a href="#四、常用DOS命令" class="headerlink" title="四、常用DOS命令"></a>四、常用DOS命令</h2><p>调用DOS功能一般方法如下：</p>
<p>1、在<strong>AH寄存器</strong>中设置系统功能调用号，说明选择的功能</p>
<p>2、在指定寄存器中设置入口参数。</p>
<p>3、用中断调用指令 INT 21H 执行功能调用。</p>
<h3 id="（一）字符输出（02H号）"><a href="#（一）字符输出（02H号）" class="headerlink" title="（一）字符输出（02H号）"></a>（一）字符输出（02H号）</h3><p>入口参数：<strong>DL</strong>=字符的ASCII码</p>
<p><img src="%E5%AD%97%E7%AC%A6%E8%BE%93%E5%87%BA.png"></p>
<p>注：该功能可以识别响铃字符（07H），回车（0DH），换行（0AH）。</p>
<h3 id="（二）字符串输出（09H号）"><a href="#（二）字符串输出（09H号）" class="headerlink" title="（二）字符串输出（09H号）"></a>（二）字符串输出（09H号）</h3><p>入口参数：<strong>DS:DX</strong>=欲显示字符串在主存中的首地址。</p>
<p><img src="%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BE%93%E5%87%BA.png"></p>
<p>注：顺序为先回车（0DH），再换行（0AH），且字符串应以’$’(24H)结束。</p>
<h3 id="（三）字符输入（01H号）"><a href="#（三）字符输入（01H号）" class="headerlink" title="（三）字符输入（01H号）"></a>（三）字符输入（01H号）</h3><p>出口参数：<strong>AL</strong>=字符的ASCII码</p>
<p><img src="%E5%AD%97%E7%AC%A6%E8%BE%93%E5%85%A5.png"></p>
<p>调用此功能时，若无键按下，则会一直等待，直到按键后才读取该键值</p>
<h3 id="（四）字符串输入（0AH号）"><a href="#（四）字符串输入（0AH号）" class="headerlink" title="（四）字符串输入（0AH号）"></a>（四）字符串输入（0AH号）</h3><p>入口参数：<strong>DS:DX</strong>=缓冲区首地址</p>
<p><strong>关键要定义好缓冲区</strong></p>
<p><img src="%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BE%93%E5%85%A5.png"></p>
<h2 id="五、8086的机器代码格式"><a href="#五、8086的机器代码格式" class="headerlink" title="五、8086的机器代码格式"></a>五、8086的机器代码格式</h2><p><img src="%E6%9C%BA%E5%99%A8%E4%BB%A3%E7%A0%81.png"></p>
<p>机器码我都不怎么懂，直接搬PPT了= =</p>
<p>例1： </p>
<p>MOV AX,BX ;机器代码是 89 D8(16进制)</p>
<p>第1个字节89是操作码(含<strong>w＝1表示16位操作</strong>)</p>
<p>第2个字节D8（11 011 000）是 “<strong>mod reg r/m</strong>”</p>
<p>reg＝011表示目的操作数为BX</p>
<p>mod＝11时，为<strong>寄存器寻址方式</strong>。</p>
<p>mod＝11和r/m＝000表示源操作数为AX</p>
<p>例2：</p>
<p>MOV AL,[BX+SI+6] ;机器代码是 8A 40（16进制） 06</p>
<p>前一个字节8A是操作码(含<strong>w＝0表示8位操作</strong>)</p>
<p>中间一个字节40（01 000 000）(将16进制转为2进制，然后按2 3 3拆开)是 “<strong>mod reg r/m</strong>”字节</p>
<p>reg＝000表示目的操作数为AL</p>
<p>mod＝01时，为<strong>带有8位位移量的存储器寻址方式</strong></p>
<p>mod＝01和r/m＝000表示源操作数为[BX+SI+D8]</p>
<p>最后一个字节就是8位位移量[D8]=06</p>
<h2 id="六、常用的ASCII码"><a href="#六、常用的ASCII码" class="headerlink" title="六、常用的ASCII码"></a>六、常用的ASCII码</h2><p><strong>回车：0DH    换行：0AH</strong>   响铃：07H</p>
<p><strong>空格：20H</strong></p>
<p><strong>数字0<del>9：30H</del>39H</strong></p>
<p>大写字母A<del>Z：41H</del>5AH</p>
<p>小写字母a<del>z：61H</del>7AH</p>
<h2 id="七、BCD码"><a href="#七、BCD码" class="headerlink" title="七、BCD码"></a>七、BCD码</h2><p>Binary Coded Decimal（二进制编码的十进制数），即<strong>一个十进制数位（0-9）在计算机中用4位二进制编码表示</strong>。常用的BCD码是8421BCD码，即用4位二进制编码的低19个编码表示0-9这十个数字，如图。</p>
<p><img src="BCD%E7%A0%81.png"></p>
<p>例：0100 1001 0111 1000.0001 0100 1001  十进制真值：4978.149（上图对应）</p>
<p>00111010B=3AH   F2H=11110010B</p>
<p>10H=00010000B=16D                        ABH=10101011B=171D</p>
<p>压缩BCD码：一个字节表达两位BCD码      10000111B（87H)</p>
<p>非压缩BCD码：<strong>一个字节表达一位BCD码</strong>（<strong>低4位表达数值，高4位常设置为0</strong>）   </p>
<p>00001000 00000111B（0807H）</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>只花了一天的时间去复习整理汇编语言，希望别挂科就好</p>
<p>后面看到这篇的人一定要好好学汇编啊。</p>
<p>张海英你没有心（确信）</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
</search>
