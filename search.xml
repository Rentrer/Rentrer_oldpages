<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>XMLSPY考试应用</title>
    <url>/2021/01/02/XMLSPY%E8%80%83%E8%AF%95%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<p>今天我们来探索一下XMLSPY，看看这个软件里有多少我们上机考能用到的东西！</p>
<p>由于<strong>我电脑上是中文版</strong>，所以读者请自行翻译回英文<strong>找相对应的位置</strong></p>
<h1 id="DTD"><a href="#DTD" class="headerlink" title="DTD"></a>DTD</h1><h2 id="（一）如何获取未知信息"><a href="#（一）如何获取未知信息" class="headerlink" title="（一）如何获取未知信息"></a>（一）如何获取未知信息</h2><p>在DTD的编写中，我们要学会通过Grid视图来获取我们所需要的信息。</p>
<p>不过首先我们要先会写一个元素和一个属性来通过有效性验证。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!ELEMENT <span class="meta-keyword">HEROS</span> (<span class="meta-keyword">hero</span>)&gt;</span></span><br><span class="line"><span class="meta">&lt;!ATTLIST A</span></span><br><span class="line"><span class="meta">    <span class="meta-keyword">id</span> <span class="meta-keyword">ID</span> <span class="meta-keyword">#REQUIRED</span></span></span><br><span class="line"><span class="meta">&gt;</span></span><br></pre></td></tr></table></figure>
<p>之后我们进入Grid视图，并选取HEROS元素（他是DTD应用到XML文档的根元素）</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="DTD元素.png" alt=""></p>
<p>我们可以看到，右上角是根元素声明时可以采取的所有类型，下面则是这个根元素的子元素们组成的方式，分别对应<strong>默认值,？,+,*</strong>。</p>
<p>下面我们来看属性</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="DTD属性.png" alt=""></p>
<p>同理，将鼠标分别点击Type和Presence（存在方式）的元素中，右上角会出现它的所有可取值，此时可以双击进行更换。这样就避免了不知道取值而不会做题的情况，较为实用。</p>
<h2 id="（二）关于DTD的自动生成问题"><a href="#（二）关于DTD的自动生成问题" class="headerlink" title="（二）关于DTD的自动生成问题"></a>（二）关于DTD的自动生成问题</h2><p>在实验中，题目是<strong>给我们.xml文件，让我们编写相对应的.dtd文件</strong>。很多同学因为对dtd不太熟悉，想通过生成直接得到答案，但这样生成的dtd往往不是老师想要的答案，那么要怎么尽量修改的像一点呢？我们拿第二次实验的SpyBase2.xml和对应的.dtd来举例子。</p>
<h3 id="1-如何从xml生成dtd？"><a href="#1-如何从xml生成dtd？" class="headerlink" title="1.如何从xml生成dtd？"></a>1.如何从xml生成dtd？</h3><p>我们使用菜单栏“DTD/Schema”目录下的“<strong>产生DTD/模式(E)</strong>”功能</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="DTD转换.png" alt=""></p>
<h3 id="2-有什么注意事项？"><a href="#2-有什么注意事项？" class="headerlink" title="2.有什么注意事项？"></a>2.有什么注意事项？</h3><p>将枚举改为0的原因是，按默认设置转换出来的dtd，会枚举每一个出现过的数值，而这在考试要求中可能并没有出现，从而使老师得知你是通过转换得来的，下面是一个对比</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="DTD注意.png" alt=""></p>
<p>在将枚举值改为零后，属性的默认类型就从枚举变成了文本类型（CDATA）</p>
<p>之后，再根据题目中说的要求，对生成后的.dtd文件进行改动。如本题中要求使用参数实体替换所有的#PCDATA和CDATA，则在dtd中编写如下代码：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!ENTITY % <span class="meta-keyword">pc</span> <span class="meta-string">&quot;#PCDATA&quot;</span>&gt;</span>   <span class="comment">&lt;!--注意空格和引号--&gt;</span></span><br><span class="line"><span class="meta">&lt;!ENTITY % <span class="meta-keyword">cd</span> <span class="meta-string">&quot;CDATA&quot;</span>&gt;</span></span><br><span class="line"><span class="meta">&lt;!ELEMENT <span class="meta-keyword">status</span> (%<span class="meta-keyword">pc</span>;)&gt;</span>   <span class="comment">&lt;!--替换实例 --&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="SCHEMA"><a href="#SCHEMA" class="headerlink" title="SCHEMA"></a>SCHEMA</h1><p>众所周知，SCHEMA很难写，所以还是得仔细过亿遍</p>
<p>我们拿第三次实验的SpyBase2.xml和对应的.xsd来举例子。</p>
<h2 id="（一）如何获取未知信息-1"><a href="#（一）如何获取未知信息-1" class="headerlink" title="（一）如何获取未知信息"></a>（一）如何获取未知信息</h2><p>同理，我们先生成一个xsd文件，再转到他的SCHEMA视图</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="XSD入口.png" alt=""></p>
<p> 这个界面会列举出你文章中的<strong>全局元素和全局类型</strong>，如果自己编写一些类型，效果如下。</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="XSD入口2.png" alt=""></p>
<p>我们点击蓝色按钮进入下一步的视图，先点击一个元素试试</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="XSD元素.png" alt=""></p>
<p>我们选取了一个具有简单类型的元素，在右侧显示出了他的元素类型、出现次数等内容，因为它属于string类型，所以下方还有进一步限制他的length等属性，直接在下方修改即可影响到XSD内的内容，比较方便。</p>
<p>下面再点一个属性</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="XSD属性.png" alt=""></p>
<p>内容与元素的基本一致，因为它属于decimal类型，所以下方还有进一步限制他的minInclusive totalDigit等属性，直接在下方修改即可影响到XSD内的内容，比较方便。</p>
<div class="note info flat"><p><strong>提示</strong></p>
    <p>minInclusive和maxInclusive是闭区间,min即最小值，max即最大值</p>
    <p>而minExclusive和maxExclusive是开区间，min即最小值+1，max是最大值-1</p>
</div>

<h2 id="（二）关于XSD的自动生成问题"><a href="#（二）关于XSD的自动生成问题" class="headerlink" title="（二）关于XSD的自动生成问题"></a>（二）关于XSD的自动生成问题</h2><h3 id="1-如何从xml生成xsd？"><a href="#1-如何从xml生成xsd？" class="headerlink" title="1.如何从xml生成xsd？"></a>1.如何从xml生成xsd？</h3><p>我们使用菜单栏“DTD/Schema”目录下的“<strong>产生DTD/模式(E)</strong>”功能，选择W3C模式</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="XSD转换.png" alt=""></p>
<h3 id="2-有什么注意事项？-1"><a href="#2-有什么注意事项？-1" class="headerlink" title="2.有什么注意事项？"></a>2.有什么注意事项？</h3><p>首先要去掉W3C模式下面第一项的勾，这样可以避免生成的子元素的类型全部为ref（引用），造成错误。</p>
<p>将枚举字符置为0的原因与DTD中一致。</p>
<p>转换之后，该xsd的大致框架便已完成，此时再根据题目中的各种约束条件，对生成后的xsd文件进行修改，若熟练的话可以直接在SCHEMA视图下进行修改，这样效率较高。</p>
<div class="note info flat"><p><strong>提示</strong></p>
    <p>①题目中可能会要求写自己定义的简单类型或者复杂类型，但自动生成的xsd文件是默认生成了无名的类型直接放在了对应的元素下，所以要特别注意这一点</p>
    <p>②自动生成的元素和属性的类型都是XMLSPY近似判断的，所以可能会出现写错的情况，要对着题目检查一遍。</p>
</div>


<div class="note danger flat"><p><strong>重点</strong></p>
   <p>记得删掉默认生成的注释</p>
</div>

<p>如果要交xml文件和xsd文件的话，记得将xsd文件约束在xml文件上，并将绝对路径改为相对路径。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">spyTable</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xsi:noNamespaceSchemaLocation</span>=<span class="string">&quot;file:///C:/Users/10971/Desktop/1.xsd&quot;</span>&gt;</span></span><br><span class="line">改为</span><br><span class="line"><span class="tag">&lt;<span class="name">spyTable</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xsi:noNamespaceSchemaLocation</span>=<span class="string">&quot;1.xsd&quot;</span>&gt;</span>  <span class="comment">&lt;!--要和xsd文件放在同一目录下--&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="XPATH"><a href="#XPATH" class="headerlink" title="XPATH"></a>XPATH</h1><h2 id="一-XPATH函数"><a href="#一-XPATH函数" class="headerlink" title="(一) XPATH函数"></a>(一) XPATH函数</h2><p>在考察XPATH时，试题更多的是考察你对XPATH表达式的理解（比如如何利用子孙关系挑选出那个元素），对XPATH函数的考察其实较少，我们只需要记住常用的几个即可。</p>
<p>我们可以曲线救国，从XQUERY中得到XPATH函数及其用法（好不容易找到的）</p>
<p>首先随便打开一个xquery文件</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="XPATH函数.png" alt=""></p>
<p>我们惊喜的发现，这些函数中的很大一部分与XPATH函数重合了。与之前一样，在你需要的地方双击即可写出这个函数，同时还有奇效</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="函数提示.png" alt=""></p>
<p>可以看到，XMLSPY提示了这个函数的参数，再加上英文名我们便可知道这个函数的用法，这样就不至于不知道到底能用哪个函数了。</p>
<p>当然你不喜欢这样的话，<strong>请参考后文：记不住正则表达式怎么办</strong></p>
<h1 id="XSLT"><a href="#XSLT" class="headerlink" title="XSLT"></a>XSLT</h1><p>没有技巧，自生自灭</p>
<h1 id="XQUERY"><a href="#XQUERY" class="headerlink" title="XQUERY"></a>XQUERY</h1><h2 id="一-如何自动缩进"><a href="#一-如何自动缩进" class="headerlink" title="(一) 如何自动缩进"></a>(一) 如何自动缩进</h2><p>在编写好.xq文件，应用在xml文件后，生成的.xml文件是默认不会缩进的，这让我们看着很头疼，无法及时分辨出XQUERY是否查询正确。</p>
<p>懂一点的朋友可能知道，在Edit栏下有一个调整排版的按钮（Pretty Print）点一下之后就可以正常显示嵌套了。</p>
<p>但是我们想像XSLT那样，默认让其具有缩进（indent=”yes”), Xquery显然也考虑到了这一点。</p>
<p>我们点开XSL/XQuery一栏，点击最下面的设置</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="XQ缩进.png" alt=""></p>
<p>勾选缩进输出后，每次查询生成的XML文件就可以默认缩进辣！强迫症狂喜</p>
<h1 id="一些小问题"><a href="#一些小问题" class="headerlink" title="一些小问题"></a>一些小问题</h1><h2 id="一-记不住预定义实体怎么办啊"><a href="#一-记不住预定义实体怎么办啊" class="headerlink" title="(一) 记不住预定义实体怎么办啊"></a>(一) 记不住预定义实体怎么办啊</h2><p>在XMLSPY中，当你打开一个.xml文件时，右下角会指出当前.xml文件中所用到的实体即：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="实体.png" alt=""></p>
<p>此时，我们只需要在需要将光标放在引入实体的地方，双击右下角你需要引入的实体，即可引入，大功告成！</p>
<h2 id="二-记不住正则表达式怎么办啊"><a href="#二-记不住正则表达式怎么办啊" class="headerlink" title="(二) 记不住正则表达式怎么办啊"></a>(二) 记不住正则表达式怎么办啊</h2><p><del>别问，问就是自己提前建一个xml文件，用注释的方式全部打进去，考试的时候再打开就好了</del></p>
<div class="note danger flat"><p><strong>注意</strong></p>
   <p>在正则表达式中，比如* . - 这些字符需要进行转义，即在他们前面加上\</p>
</div>

<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>不想复习XML，但是不得不复习</p>
<p>宋亮教的真好啊！</p>
]]></content>
      <categories>
        <category>XML开发技术</category>
      </categories>
      <tags>
        <tag>课内学习笔记</tag>
        <tag>考试复习整理</tag>
      </tags>
  </entry>
  <entry>
    <title>XML开发技术——第一章</title>
    <url>/2020/11/14/XML%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
    <content><![CDATA[<p>可能你还不了解XML，只是听说课水分高就报了(<del>我也是</del>)，那就跟着我的笔记，来一起了解XML吧！</p>
<p>本系列笔记适合读过课本后过来进行总结，所以还是要先预习啊(<del>双关</del>)</p>
<p><code>注：这系列的笔记将多采用Q E C形式，即 Question Evidence Conclusion 的形式</code> </p>
<a id="more"></a>
<h1 id="XML基础知识"><a href="#XML基础知识" class="headerlink" title="XML基础知识"></a>XML基础知识</h1><h2 id="1-1-XML及其相关技术概述"><a href="#1-1-XML及其相关技术概述" class="headerlink" title="1.1 XML及其相关技术概述"></a>1.1 XML及其相关技术概述</h2><p>Q1：什么是XML？</p>
<p>C1：XML(eXtensible Markup Language)，即<strong>可扩展性标记语言</strong>，是标记语言中的一种。</p>
<p>Q2：什么是标记？</p>
<p>C2：标记是指计算机所能理解的信息符号，通过标记，计算机之间可以相互表示包含各种信息的文档。</p>
<h3 id="1-1-1-XML的发展史"><a href="#1-1-1-XML的发展史" class="headerlink" title="1.1.1 XML的发展史"></a>1.1.1 XML的发展史</h3><p>Q3：标记语言(ML)的发展过程是什么？</p>
<p>C3：</p>
<ol>
<li>SGML，它是XML的前身，由三部分构成，即语法定义、文件类型定义DTD和文件实例。但由于它<strong>过于庞大复杂，难以理解学习</strong>，真正大行其道的是其子集，如HTML和XML。</li>
<li>HTML，它是SGML的一种实际应用，其DTD作为标准被固定下来。因此，<strong>HTML的功能单一，只能用于编写网页</strong>。</li>
<li>XML，它是一套使用上规则严谨，但是语法简单的信息描述语言。它的目的是以一种更中立的方式，让用户自行决定要如何理解、呈现从服务端所提供的信息，<strong>而着重表示数据以及数据之间的联系。</strong></li>
</ol>
<h3 id="1-1-2-XML的特点"><a href="#1-1-2-XML的特点" class="headerlink" title="1.1.2  XML的特点"></a>1.1.2  XML的特点</h3><p>Q4：XML的特点主要包含什么？</p>
<p>C4：主要包含四个方面：</p>
<ol>
<li><strong>可扩展性</strong>：XML允许使用者<strong>创建和使用他们自己的标记</strong>，而不是HTML的有限词汇表。</li>
<li><strong>灵活性</strong>：XML提供了一种<strong>结构化的数据表示方式</strong>，使得用户界面分离于结构化数据，使得Web用户所追求的许多先进功能在XML环境下更容易实现。</li>
<li><strong>自描述性</strong>：XML文档通常包含一个文档类型声明，<strong>不仅人能读懂，计算机也能处理</strong>，XML表示数据的方式真正做到了独立于应用系统，并且数据能够重用。</li>
</ol>
<p>示例文档</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="示例.png" alt=""></p>
<ol>
<li><strong>简洁性</strong>：XML比完整的SGML简单得多，<strong>易学、易用并且以实现</strong>。</li>
</ol>
<p>XML文档包含三个不同的组成部分：</p>
<ol>
<li><p>数据内容：即文档本身（<strong>对应XML</strong>）</p>
</li>
<li><p>结构：文档类型及其元素的组织形式，文档包括何种类型的元素，以及他们的排列次序（<strong>对应DTD/SCHEMA</strong>)</p>
</li>
<li>表现形式：在一张纸上、浏览器屏幕上向读者描述数据的方法，还有对每种元素类型使用何种字体等。(<strong>对应XSL/CSS</strong>)</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="组成部分.png" alt=""></p>
<h3 id="1-1-3-XML的实际应用"><a href="#1-1-3-XML的实际应用" class="headerlink" title="1.1.3 XML的实际应用"></a>1.1.3 XML的实际应用</h3><p>XML 成为一种<strong>与平台无关</strong>的、<strong>数据表示</strong>和<strong>数据交换</strong>的载体。</p>
<h2 id="1-2-XML规范及XML文档分类"><a href="#1-2-XML规范及XML文档分类" class="headerlink" title="1.2 XML规范及XML文档分类"></a>1.2 XML规范及XML文档分类</h2><p>XML文档实际上是一个文本文件，但并不是任何文本文件都是正确的XML文档，W3C的XML1.0规范对XML文档的语法格式进行了严格的定义。</p>
<h3 id="1-2-1-XML文档中的XML声明"><a href="#1-2-1-XML文档中的XML声明" class="headerlink" title="1.2.1 XML文档中的XML声明"></a>1.2.1 XML文档中的XML声明</h3><p>Q5：声明有哪些特点和注意事项？</p>
<p>E5：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;</span></span><br></pre></td></tr></table></figure>
<p>C5：</p>
<p>XML声明部分<strong>本身是可选的</strong>（可以没有声明）。但如果包含声明部分，必须是整个XML文档的第一行内容（<strong>第一行不能为注释或空行</strong>）。&lt;?xml要顶格，且中间无空格。</p>
<p>完整的 XML 声明包括三个部分：</p>
<p>(1) 版本声明 (<strong>version</strong>)通常情况下为1.0，<strong>在声明中是必须的</strong>，并且必须为作为<strong>第一个属性</strong>出现。</p>
<p>(2) 编码声明 (<strong>encoding</strong>)该属性的取值用于指明当前XML文档中所使用的符号的编码方式。一般采用”UTF-8”,这个属性是<strong>可选</strong>的（默认为UTF-8)。</p>
<p>注：<strong>这个编码方式与XML在文档在系统中保存时使用的编码方式没有直接关系</strong>。</p>
<p>(3) 文档独立性声明 (<strong>standalone</strong>)该属性的取值表明当前XML文件是否独立使用、还是与其他标记文件配套使用。若为“yes”,则解析当前XML文档时无需其他的外部标记声明文件。若为”no“，则可能需要使用外部的标记声明文件。这个属性是<strong>可选</strong>的。</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="独立性.png" alt=""></p>
<p>示例中，no的原因是因为该文档引用了外部1.ent中定义的实体：<em>&amp;nbsp</em></p>
<p>而<strong>如果存在外部标记声明</strong>，且没有standalone声明，则解析器将认为<strong>standalone的值为no</strong></p>
<p>如果有encoding 属性和standalone属性，那么<strong>encoding属性必须放standalone属性前面</strong>。</p>
<h3 id="1-2-2-处理指令和注释"><a href="#1-2-2-处理指令和注释" class="headerlink" title="1.2.2 处理指令和注释"></a>1.2.2 处理指令和注释</h3><p>Q6：什么是处理指令？</p>
<p>E6：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml-stylesheet href=&quot;style.xsl&quot; type=&quot;text/xsl&quot;?&gt;</span></span><br></pre></td></tr></table></figure>
<p>C6：处理指令是表示将XML文档用于特殊的应用程序时表示需要执行的特定操作，而XML解析器不会执行特定的操作。</p>
<p>语法格式：<code>&lt;? target-name data ?&gt;</code></p>
<p>其中，<strong>&lt;?和?&gt;表示处理指令的开始与结束</strong>；target-name表示该处理指令的<strong>名称</strong>，data部分描述该指令的<strong>具体内容</strong>。E6的含义为：当XSL的执行引擎碰到这个处理指令时，将会根据href的取值获得指定的xsl文件，并对输入的xml文档进行相应的转换。</p>
<p>Q7：注释的注意事项是什么？</p>
<p>C7：语法格式 <code>&lt;!--......--&gt;</code>,与HTML一致。</p>
<p>​        在注释的内容中，<strong>不应该出现两个连续的横线</strong>。</p>
<p>​        注释不应该出现在元素的标记中，<strong>注释之中不应该嵌套注释</strong>。</p>
<h3 id="1-2-3-XML文档中的元素和属性"><a href="#1-2-3-XML文档中的元素和属性" class="headerlink" title="1.2.3 XML文档中的元素和属性"></a>1.2.3 XML文档中的元素和属性</h3><p>Q8：什么是元素？</p>
<p>E8：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">element_name</span> <span class="attr">att1</span>=<span class="string">&quot;val1&quot;</span> <span class="attr">att2</span>=<span class="string">&quot;val2&quot;</span>&gt;</span></span><br><span class="line">    ...content...</span><br><span class="line"><span class="tag">&lt;/<span class="name">element_name</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>C8：元素是最基本的组成单元，在元素的开始标记中还可以包含相关的属性。元素中可以包含文本、子元素、或者两者的组合。可以存在空元素，即<strong>不包含任何内容</strong>的元素，但它<strong>可以包含属性</strong>：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">details</span>&gt;</span><span class="tag">&lt;/<span class="name">details</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">details</span>/&gt;</span><span class="comment">&lt;!--上述两种空元素是等价的--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">details</span> <span class="attr">about</span>=<span class="string">&quot;Location&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">details</span>&gt;</span><span class="comment">&lt;!--空元素可以包含属性--&gt;</span></span><br></pre></td></tr></table></figure>
<p>一个元素可以包含任意多个子元素，<strong>可以包含多个同名的子元素</strong>；子元素的<strong>顺序非常重要</strong>。</p>
<p>Q9：什么是属性？</p>
<p>E9：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">author</span> <span class="attr">firstname</span>=<span class="string">&quot;Tom&quot;</span> <span class="attr">lastname</span>=<span class="string">&quot;hanks&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>C9：<strong>属性不能独立于元素而存在</strong>，通常以名-值对的形式出现，用于描述当前元素的某个方面的特征。</p>
<p>​        <strong>属性的取值必须加上引号（单引号或者双引号）</strong></p>
<p>元素在其开始标记中可以包含任意多个属性，但<strong>不能包含同名的属性</strong>。</p>
<p>对于一个元素所有的属性，<strong>它们不分先后顺序</strong>，因为它们之间可以通过名称相互区别。</p>
<p>Q10：如何命名元素和属性？</p>
<p>E10：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">example-one</span>/&gt;</span> <span class="tag">&lt;<span class="name">_example2</span>/&gt;</span> <span class="tag">&lt;<span class="name">:Example.Three</span>/&gt;</span> <span class="comment">&lt;!--这些标记名称都是正确的--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bad*character</span>/&gt;</span> <span class="tag">&lt;<span class="name">illegal</span> <span class="attr">space</span>/&gt;</span> <span class="tag">&lt;<span class="name">12number-start</span>/&gt;</span><span class="comment">&lt;!--这些都是错误的--&gt;</span></span><br></pre></td></tr></table></figure>
<p>C10：</p>
<ol>
<li>名称的开头必须以<strong>字母、下划线或者冒号</strong>开头。</li>
<li>除开头之外的其他部分可以是字母、数字、<strong>横线(-)</strong>、下划线、<strong>点号(.)、冒号</strong>的任意组合。</li>
<li><strong>元素名称分大小写</strong>。</li>
<li>元素和属性的名称长度没有限制。</li>
<li>可以使用非英文的元素名。</li>
</ol>
<p>Q11：如何选择子元素和属性的使用？</p>
<p>C11：</p>
<ol>
<li>对于简单的标量数据（<strong>无结构的数据</strong>），可以采用属性，否则应该采用子元素。</li>
<li>对于可能在<strong>数目上发生变化的特性</strong>，应该使用子元素，比如某本书籍可能有多个作者。</li>
</ol>
<h3 id="1-2-4-XML文档中的文本内容和CDATA段"><a href="#1-2-4-XML文档中的文本内容和CDATA段" class="headerlink" title="1.2.4 XML文档中的文本内容和CDATA段"></a>1.2.4 XML文档中的文本内容和CDATA段</h3><p>在文本内容中，一些符号会产生歧义，使得解析器不能正确辨识。比如</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;lessthan&gt;one&lt;two&lt;/lessthan&gt; &lt;!--文本中的小于号产生了歧义--&gt;</span><br></pre></td></tr></table></figure>
<p>XML 1.0 规范中定义了五种预定义实体：而<strong>除此以外的的其他实体，必须在使用前进行声明</strong>。</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="预定义实体.png" alt=""></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">lessthan</span>&gt;</span>one <span class="symbol">&amp;it;</span>two<span class="tag">&lt;/<span class="name">lessthan</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注：预定义实体<strong>以&amp;表示实体的开始</strong>，<strong>最后有一个分号</strong>表示实体的结束，容易遗漏，特别注意 </p>
<p>Q12：什么是CDATA段？</p>
<p>E12：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">customer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>&lt;![CDATA[YOU &amp; ME,&lt;Tom&gt;&amp;&lt;Jerry&gt;]]&gt;<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">customer</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>C12: 假设XML文档的某块文本内容中<strong>包含大量的特殊字符</strong>，那么可以将整个文本块的内容放入到一个CDATA段中</p>
<p>即：<code>&lt;![CDATA[]]&gt;</code></p>
<p>使用 CDATA 段，可以告诉<strong>解析器不要试图从该文本块中查找 XML 标记</strong>，<strong>它仅仅就是文本内容</strong>，从而避免了歧义的产生，因此<strong>可以使用非法字符</strong>。</p>
<p>同理，CDATA段的文本内容中<strong>不能直接出现]]&gt;</strong>，并且CDATA段<strong>不应该嵌套使用</strong>。（与注释类似）</p>
<p>Q13：什么是空白字符？</p>
<p>C13：XML文档中的空白字符包括空格、回车、换行、制表等四种符号。</p>
<p>注：在<strong>缺省</strong>的情况下，对于连续出现的空白字符，解析器会将其<strong>缩减为一个空格字符</strong>。如果准备<strong>显示标记包含的全部空格</strong>，在编辑xml文件时将输入法换成<strong>“中文”输入法</strong>，并选择“<strong>全角状态”来编辑空格字符</strong>。</p>
<h3 id="1-2-5-XML文档的良构性规则"><a href="#1-2-5-XML文档的良构性规则" class="headerlink" title="1.2.5 XML文档的良构性规则"></a>1.2.5 XML文档的良构性规则</h3><p>Q14：良构的XML文档要满足什么要求？</p>
<p>C14:</p>
<ol>
<li>开始标记必须与结束标记相对应。</li>
<li>标记是大小写敏感的。</li>
<li>标记必须正确的嵌套。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">book</span>&gt;</span><span class="tag">&lt;<span class="name">author</span>&gt;</span>tom hanks<span class="tag">&lt;/<span class="name">book</span>&gt;</span><span class="tag">&lt;/<span class="name">author</span>&gt;</span> <span class="comment">&lt;!--这是错误的--&gt;</span></span><br></pre></td></tr></table></figure>
<ol>
<li>属性值必须使用引号括起来：</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">details</span> <span class="attr">about</span>=<span class="string">Location/</span>&gt;</span> <span class="comment">&lt;!--不加引号是错误的，可加单引号或双引号--&gt;</span></span><br></pre></td></tr></table></figure>
<ol>
<li>有且只有一个根元素。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">author</span>&gt;</span>tom hanks<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">author</span>&gt;</span>mike jimmy<span class="tag">&lt;/<span class="name">author</span>&gt;</span><span class="comment">&lt;!--这段内容称为XML片段--&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="1-2-6-XML文档的分类"><a href="#1-2-6-XML文档的分类" class="headerlink" title="1.2.6 XML文档的分类"></a>1.2.6 XML文档的分类</h3><p>XML 既可以是<strong>面向数据</strong>（Data Centric）的，又可以是<strong>面向文档</strong>（Document Centric）的。</p>
<p>面向数据的文档主要利用 XML 来传送应用数据，这些文档包括销售订单（参见 data-centric.xml）、病人记录和科学数据等。</p>
<p>面向数据的 XML 文档的物理结构，如元素的顺序、或者数据被存储为属性还是子元素，通常不是很重要。它们的特征是高度有序的结构，并且同时带有那些数据结构的多个项目，类似于关系数据库系统中的多条记录。 </p>
<p>面向文档的 XML 文件几乎没有结构，元素结构粗糙。面向文档的文档是利用 XML 来获取自然（人类）语言的那些文档，如留言信息（参见 doc-centric.xml）、用户手册。 </p>
<p>它们以复杂或无规则的结构和混合内容为特征，而且文档的物理结构非常重要。这些文档的处理侧重于给用户提供信息的最终表示，因此它们也被称作面向表示的文档。 </p>
<h2 id="1-3-命名空间"><a href="#1-3-命名空间" class="headerlink" title="1.3 命名空间"></a>1.3 命名空间</h2><p>Q15：什么是命名空间？</p>
<p>C15：命名空间 (namespace) 主要是通过某种形式来表示标识符 (identifier) 的上下文，可以将逻辑上相关的标识符组织成相应的命名空间，可使整个系统更加模块化。 </p>
<h3 id="1-3-2-XML中命名空间的声明和使用"><a href="#1-3-2-XML中命名空间的声明和使用" class="headerlink" title="1.3.2 XML中命名空间的声明和使用"></a>1.3.2 XML中命名空间的声明和使用</h3><p>Q16：如何声明命名空间？</p>
<p>E16：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">myns:element</span> <span class="attr">xmlns:myns</span>=<span class="string">&quot;http://www.myns.com&quot;</span>&gt;</span></span><br><span class="line">    .....</span><br><span class="line"><span class="tag">&lt;/<span class="name">myns:element</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>C16：声明XML命名空间的语法为：<strong>xmlns:prefix-name=”URI”</strong>。其中，<strong>xmlns是XML的保留属性，用来声明命名空间</strong>。命名空间的前缀名称是以字母或下划线（_）开头的、<strong>不包含空白字符和冒号（:）</strong>的字符串，通常规定<strong>不应该使用 XML 中的保留字</strong>，比如 xml、xsl 等等。</p>
<p>对于例子，myns:element表示element元素属于myns这个命名空间，而myns只是命名空间的简称，后面的语句才是命名空间的声明，表示myns命名空间的全程为字符串”<a href="http://www.myns.com&quot;。">http://www.myns.com&quot;。</a></p>
<p>Q17：为什么不建议用简短的字符串作为命名空间的全称？</p>
<p>C17：为了减少不同命名空间标识符冲突的可能性。</p>
<p>Q18：怎样使用缺省命名空间？</p>
<p>E18：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">company</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.myns.com&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">company-info</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>SoftwareBG<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">fdate</span>&gt;</span>2007-03-17<span class="tag">&lt;/<span class="name">fdate</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">ns1:division</span> <span class="attr">xmlns:ns1</span>=<span class="string">&quot;http://www.myns.com/division&quot;</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">ns1:name</span>&gt;</span>Development<span class="tag">&lt;/<span class="name">ns1:name</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">ns1:employees</span>&gt;</span>100<span class="tag">&lt;/<span class="name">ns1:employees</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">ns1:division</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">company-info</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">company</span>&gt;</span> </span><br></pre></td></tr></table></figure>
<p>C18：由例子：根元素company的<strong>开始标记中声明了一个无前缀名的命名空间，它的作用范围为整个XML文档</strong>。因此在该文档中，<strong>任何没有显示地指定命名空间的元素和属性</strong>（即除了disivion命名空间下的其他），都属于这个缺省的无名命名空间。</p>
<p>教学要求：能较系统地了解XML及其相关技术概述，XML在各个领域方面的应用，XML规范及XML文档分类，命名空间，XML数据模型规范等；</p>
<h2 id="1-4-XML文档的数据模型规范"><a href="#1-4-XML文档的数据模型规范" class="headerlink" title="1.4 XML文档的数据模型规范"></a>1.4 XML文档的数据模型规范</h2><p>以下片段都将转化为<code>&lt;a b=&#39;upcase&#39;&gt; Hello! &lt;/a&gt;</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">b</span>=<span class="string">&#x27;upcase&#x27;</span>&gt;</span> <span class="tag">&lt;<span class="name">[CDATA[Hello!]]</span>&gt;</span> <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">b</span>=<span class="string">&#x27;upcase&#x27;</span>&gt;</span> Hello&amp;#33 <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="结"><a href="#结" class="headerlink" title="结"></a>结</h1><p>XML第一章的内容都属于基础，比较简单，多考于选择题，因此需要广覆盖知识点，不要在这里失分。</p>
]]></content>
      <categories>
        <category>XML开发技术</category>
      </categories>
      <tags>
        <tag>课内学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>XML开发技术——第五章</title>
    <url>/2020/11/25/XML%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%AC%E4%BA%94%E7%AB%A0/</url>
    <content><![CDATA[<p>经过了上一次的学习，我们学到了用于查询的XPATH，它会在之后的很多地方予以应用。</p>
<p>比如今天我们要讲的XSLT</p>
<a id="more"></a>
<h1 id="第五章-XSLT"><a href="#第五章-XSLT" class="headerlink" title="第五章 XSLT"></a>第五章 XSLT</h1><p>本章内容的学习目的：</p>
<ol>
<li>理解和掌握XML文档的转换过程。</li>
<li>学习如何使用XSLT中的模板实现XML文档的转换。</li>
<li>学习如何使用XSLT中的排序、循环、条件分支语句实现各种处理。</li>
<li>创建使用参数和变量的XSLT文档。</li>
</ol>
<h2 id="5-1-XSLT"><a href="#5-1-XSLT" class="headerlink" title="5.1 XSLT"></a>5.1 XSLT</h2><p>Q1：什么是XSLT？</p>
<p>C1：XSLT(e<strong>X</strong>tensible <strong>S</strong>tylesheet <strong>L</strong>anguage <strong>Transformations</strong>)，其中的T表示“转换”，它是一种专门用于对XML树型数据进行<strong>结构重组转换</strong>的有力工具，可以根据指定的<strong>转换规则</strong>（在XSLT中称之为模板）将一个XML文档树或者其中的部分内容转换为另一种文档树形式。</p>
<p>XSLT不仅局限于结构上的重组，它可以<strong>将XML文档转换为任何形式</strong>，包括XML、HTML和普通文本。</p>
<p>XSL是它的前身,本来包含了XML数据表达和数据转换。数据转换部分从中独立出来成为XSLT。剩下的数据表达部分成为XSL-FO</p>
<p>Q2：XSLT有什么注意事项？</p>
<p>C2：</p>
<ol>
<li>XSLT语言是一种声明性的语言，即XSLT程序本身<strong>只是包含了一些转换规则的XML文档。</strong></li>
<li>XSLT处理程序（或称之为执行引擎）将首先确定 XSLT规则，然后根据规则的<strong>匹配条件</strong>（<strong>通过XPath 表达式</strong>指定）、以及优先顺序完成相应的转换操作。</li>
<li><strong>XSLT本身也是一个XML文档</strong>，所以它必须严格遵守XML规范。其根元素的命名空间为<code>http://www.w3.org/1999/XSL/Transform</code> 即：</li>
</ol>
<p><code>&lt;xsl:stylesheet version=&quot;2.0&quot; xmlns:xsl=&quot;http://www.w3.org/1999/XSL/Transform&quot;&gt;</code></p>
<h3 id="5-1-1-XSLT的工作原理"><a href="#5-1-1-XSLT的工作原理" class="headerlink" title="5.1.1 XSLT的工作原理"></a>5.1.1 XSLT的工作原理</h3><p>Q3：XSLT是怎样工作的？</p>
<p>E3：<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="工作原理.png" alt=""></p>
<p>C3：</p>
<ol>
<li>在进行XSLT的转换任务时，需要<strong>两个输入文档</strong>，一个是包含源数据的<strong>XML文档</strong>，一个是包含转换任务规则的<strong>XSLT文档</strong>。</li>
<li>由XML解析器对这两个文档进行解析，将XML文档转换为所对应的文档树结构，<strong>将xslt(xsl)文档看作是一系列的转换规则</strong>。</li>
<li><strong>由XSLT引擎调用这些规则</strong>，对文档树进行遍历，分别处理其中指定的数据节点，将其转换为所需的结果集，并序列化为结果文档。</li>
</ol>
<h3 id="5-1-2-XSLT的一个简单示例"><a href="#5-1-2-XSLT的一个简单示例" class="headerlink" title="5.1.2 XSLT的一个简单示例"></a>5.1.2 XSLT的一个简单示例</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;hello.xlst&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">message</span>&gt;</span>Hello!<span class="tag">&lt;/<span class="name">message</span>&gt;</span>       <span class="comment">&lt;!--这是hello.xsl文档--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xsl:stylesheet</span> <span class="attr">version</span>=<span class="string">&quot;2.0&quot;</span> <span class="attr">xmlns:xsl</span>=<span class="string">&quot;http://www.w3.org/1999/XSL/Transform&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- transform the input root (/) --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">xsl:template</span> <span class="attr">match</span>=<span class="string">&quot;/&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">html</span>&gt;</span> </span><br><span class="line">        		<span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line">            		<span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><br><span class="line">	        			<span class="tag">&lt;<span class="name">xsl:value-of</span> <span class="attr">select</span>=<span class="string">&quot;message&quot;</span>/&gt;</span></span><br><span class="line">					<span class="tag">&lt;/<span class="name">h1</span>&gt;</span> </span><br><span class="line">      			<span class="tag">&lt;/<span class="name">body</span>&gt;</span>    		</span><br><span class="line">			<span class="tag">&lt;/<span class="name">html</span>&gt;</span>       </span><br><span class="line">		<span class="tag">&lt;/<span class="name">xsl:template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xsl:stylesheet</span>&gt;</span>              <span class="comment">&lt;!--这是hello.xslt文档--&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="5-2-XSLT中模板的创建以及内置模板的使用"><a href="#5-2-XSLT中模板的创建以及内置模板的使用" class="headerlink" title="5.2 XSLT中模板的创建以及内置模板的使用"></a>5.2 XSLT中模板的创建以及内置模板的使用</h2><h3 id="5-2-1-XSLT中模板的声明"><a href="#5-2-1-XSLT中模板的声明" class="headerlink" title="5.2.1 XSLT中模板的声明"></a>5.2.1 XSLT中模板的声明</h3><p>Q4：怎么声明模板？</p>
<p>E4：<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="模板声明.png" alt=""></p>
<p>C4：模板标记之间的内容相当于一个<strong>函数的函数体</strong>，表示在调用该模板时应该执行的具体操作。而元素开始标记中的属性match、name、mode和priority则用于描述该模板的相关信息。</p>
<p>Q5：模板有哪些属性？</p>
<p>C5：</p>
<ol>
<li>匹配路径属性 match</li>
</ol>
<p>在XSLT中，模板的调用分为两种方式：</p>
<p><strong>●根据模板的匹配路径</strong>（在遍历的过程中）调用，具体又有两种情况：</p>
<p>i. 对于模板 xsl:template match=”/“，XSLT 处理器在碰到 XML 文档的文档节点时自动调用该模板，就好像作为<strong>程序执行的入口</strong>。</p>
<p>ii. 对于其他的模板match=other-pattern，将在模板xsl:template match=”/“的转换规则（函数体）中通过指出匹配路径的方式（使用xsl:apply-templates）进行隐式地或者显式地调用。</p>
<p>●<strong>根据模板名称属性</strong>，使用 xsl:call-template name=template-name  进行调用。 </p>
<ol>
<li>名称属性 name</li>
</ol>
<p>模板<xsl:template match=“/”>和<xsl:template match=“message”>都没有具体的名称，因此将其称为<strong>无名模板</strong>。这些模板之所以没有名称，是因为<strong>它们的调用是在遍历文档树的过程中自动进行的</strong>，不需要名称。</p>
<p>也可以使用name属性为模板指定一个名称，使其成为命名模板 。例</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xsl:stylesheet</span> <span class="attr">version</span>=<span class="string">&quot;2.0&quot;</span> <span class="attr">xmlns:xsl</span>=<span class="string">&quot;http://www.w3.org/1999/XSL/Transform&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xsl:template</span> <span class="attr">match</span>=<span class="string">&quot;/&quot;</span> <span class="attr">name</span>=<span class="string">&quot;one&quot;</span>&gt;</span>              <span class="comment">&lt;!--命名模板 one--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">xsl:call-template</span> <span class="attr">name</span>=<span class="string">&quot;another&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">xsl:template</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">xsl:template</span> <span class="attr">name</span>=<span class="string">&quot;another&quot;</span>&gt;</span>                    <span class="comment">&lt;!--命名模板 another--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">output</span>&gt;</span>Simple output<span class="tag">&lt;/<span class="name">output</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">xsl:template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xsl:stylesheet</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>XSLT 处理器将调用命名模板 one（实际上名称 one 没有作用，因为是自动调用的），然后<strong>在模板 one 中使用 xsl:call-template 直接调用名为 another 的模板</strong>，在模板 another 执行结束之后，继续执行模板 one 的后续指令，<strong>这个过程非常类似于函数的调用</strong>。 </p>
<ol>
<li>模式属性 mode</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="mode.png" alt=""></p>
<ol>
<li>优先级属性 priority</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="优先级.png" alt=""></p>
<p>注意：XSLT中<strong>允许存在同名的模板</strong>；</p>
<p>当没有priority属性时，将执行<strong>后声明的模板</strong>；</p>
<p>有priority属性时，将使用 <strong>priority取值较大</strong>的模板。 </p>
<ol>
<li>返回类型属性 as</li>
</ol>
<p>模板返回类型属性as的取值，表示<strong>该模板应该返回的数据类型</strong>。</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="as.png" alt=""></p>
<p>注：该返回的XML元素<strong>包含了子元素和文本内容</strong>。</p>
<p>模板的返回类型属性<strong>as是一个可选的参数</strong>，如果不指定该参数，则模块可以<strong>输出任意的文本内容</strong>。</p>
<h3 id="5-2-1-XSLT中模板的调用"><a href="#5-2-1-XSLT中模板的调用" class="headerlink" title="5.2.1 XSLT中模板的调用"></a>5.2.1 XSLT中模板的调用</h3><h4 id="1-使用xsl-apply-templates-调用模板"><a href="#1-使用xsl-apply-templates-调用模板" class="headerlink" title="1.使用xsl:apply-templates 调用模板"></a>1.使用xsl:apply-templates 调用模板</h4><p>调用顺序：在<strong>广度优先</strong>、逐层向下的遍历过程中，指定继续遍历<strong>当前节点的所有子节点</strong></p>
<p>完整语法：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xsl:apply-templates</span> <span class="attr">select</span>=<span class="string">Expression</span> <span class="attr">mode</span>=<span class="string">QName</span>&gt;</span></span><br><span class="line">        ......</span><br><span class="line"><span class="tag">&lt;/<span class="name">xsl:apply-templates</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对于xsl:apply-templates元素，<strong>select和mode属性都是可选的</strong>，即可以直接使用<code>&lt;xsl:apply-templates/&gt;</code></p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="模板1.png" alt=""></p>
<p>对于上例，XSLT自动调用模板1，开始对整个XML文档树的遍历，即依次调用“处理指令”、“message元素”所对应的模板。所以模板1中使用了<code>&lt;xsl:apply-templates/&gt;</code>，表示<strong>调用当前节点的所有子节点所对应的模板</strong>。若模板1中无<code>&lt;xsl:apply-templates/&gt;</code>，<strong>遍历过程将中断</strong>，不会处理除文档节点”/“之外的任何节点。</p>
<p>下面介绍该元素的两个属性</p>
<ol>
<li>select(<strong>取值为一个XPath表达式</strong>）允许指定<strong>仅遍历当前节点的哪些子节点</strong>（以调用相应的模板）</li>
</ol>
<p>例：<code>&lt;xsl:apply-templates select=&quot;message&quot;/&gt;</code>仅调用“message元素”所对应的模板</p>
<ol>
<li>mode属性指定需要在match属性取值相同的模板中，选择哪一个进行调用。</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="mode2.png" alt=""></p>
<h4 id="2-使用xsl-call-template-调用模板"><a href="#2-使用xsl-call-template-调用模板" class="headerlink" title="2.使用xsl:call-template 调用模板"></a>2.使用xsl:call-template 调用模板</h4><p>在xsl:template元素开始标记和结束标记之间，使用 xsl:param元素为所在的模板声明参数，其as属性可以指定参数的数据类型。 例</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="参数.png" alt=""></p>
<p>注：用于为模板声明参数的<strong>xsl:param元素必须出现在模板正文的前面</strong></p>
<p>​        在模板正文中，使用<strong>$+’模板参数名’</strong>来引用模板参数，以避免将其作为字符串进行处理。</p>
<h3 id="5-2-2-XSLT中的内置模板"><a href="#5-2-2-XSLT中的内置模板" class="headerlink" title="5.2.2 XSLT中的内置模板"></a>5.2.2 XSLT中的内置模板</h3><p>Q6：怎样分析内置模板？</p>
<p>E6：<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="内置模板.png" alt=""></p>
<p>C6：模板1’的<code>match=“*|/”</code>是用于处理文档节点和所有元素节点（使用了通配符*），该模板的任务是调用所有子节点的处理模板。</p>
<p>​        模板2‘的<code>match=“text()|@*”,</code>表示它用于处理文本节点和所有属性节点（使用了通配符@<em>），由于文本节点和属性节点不可能再包含子节点，所以这个模板的任务是直接打印出当前节点（文本节点和属性节点）的内容(<em>*<xsl:value-of select="."/></em></em>)</p>
<p>Q7：内置模板有什么作用？</p>
<p>C7：内置模板中仅对<strong>文本节点和属性节点</strong>进行了处理，即输出了其文本内容。其作用在于：让我们<strong>集中精力编写相关节点的处理模板，而无需过多地操心整个遍历过程中模板的逐层调用</strong>。只有在用户没有自定义处理某个节点的模块规则时，才会调用内置模块中的规则；否则，<strong>用户自定义的模块规则将覆盖内置模块中的规则</strong>。</p>
<p>Q8：内置模板存在什么问题？</p>
<p>E8：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="错误XML.png" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="模板错误.png" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="错误解答.png" alt=""></p>
<p>C8：在Company模板中，<code>&lt;xsl:apply-templates/&gt;</code>将调用其子节点(Name和Person)的处理模板。但这时<strong>不存在match=“Name”的模板</strong>（修改错误时则只需要加上空模板Name即可），于是调用默认模板（先1后2），<strong>输出了文本节点的内容</strong>，导致文本节点的内容输出了两次，而Person的子元素Name没有出现两次。</p>
<h2 id="5-3-XSLT模板中各种转换功能的实现"><a href="#5-3-XSLT模板中各种转换功能的实现" class="headerlink" title="5.3 XSLT模板中各种转换功能的实现"></a>5.3 XSLT模板中各种转换功能的实现</h2><h3 id="5-3-1-value-of-text"><a href="#5-3-1-value-of-text" class="headerlink" title="5.3.1 value-of   text"></a>5.3.1 value-of   text</h3><p>Q9：如何使用value-of？</p>
<p>E9：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">message</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">subject</span>&gt;</span>I<span class="tag">&lt;/<span class="name">subject</span>&gt;</span><span class="tag">&lt;<span class="name">predicate</span>&gt;</span>Love<span class="tag">&lt;/<span class="name">predicate</span>&gt;</span><span class="tag">&lt;<span class="name">object</span>&gt;</span>You<span class="tag">&lt;/<span class="name">object</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">message</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">xsl:value-of</span> <span class="attr">select</span>=<span class="string">&quot;.&quot;</span>/&gt;</span>   <span class="comment">&lt;!--会输出ILoveYou--&gt;</span></span><br></pre></td></tr></table></figure>
<p>C9：对于文本节点和属性节点，xsl:value-of select=“.” 当然提取的是文本节点的内容和属性节点的取值；对元素节点使用 <xsl:value-of select=“.”/>，那么将得到元素节点的 String-Value,如上例。</p>
<p>Q10：如何输出空格？</p>
<p>E10：<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="text空白字符.png" alt=""></p>
<p>C10：此时应该使用<code>&lt;xsl:text&gt;&lt;xsl:text/&gt;</code>。xsl:text元素开始标记和结束标记<strong>之间的内容会原封不动的输出到结果中</strong>，但是其中不能包含其他XML的标记。</p>
<h3 id="5-3-2-xsl-for-each-xsl-sort"><a href="#5-3-2-xsl-for-each-xsl-sort" class="headerlink" title="5.3.2 xsl:for-each xsl:sort"></a>5.3.2 xsl:for-each xsl:sort</h3><p>Q11：怎么使用<strong>for-each与sort</strong>？</p>
<p>E11：</p>
<table><tr>
<td><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="E:\myblog\Procrastination\source\_posts\XML开发技术——第五章\for-each.jpg" border=0></td>
<td><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="E:\myblog\Procrastination\source\_posts\XML开发技术——第五章\结果.jpg" border=0></td>
</tr>
</table>

<p>C11：例中选择出了所有person的子元素Name，并将它们进行排序，随后进行输出。</p>
<p>关于sort的语法：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xsl:sort</span> <span class="attr">select</span>=<span class="string">expression</span> </span></span><br><span class="line"><span class="tag">          <span class="attr">data-type</span>=<span class="string">&#123;</span>&quot;<span class="attr">text</span>&quot;|&quot;<span class="attr">number</span>&quot;|<span class="attr">QName</span>&#125; </span></span><br><span class="line"><span class="tag">          <span class="attr">order</span>=<span class="string">&#123;</span>&quot;<span class="attr">ascending</span>&quot;|&quot;<span class="attr">descending</span>&quot;&#125; </span></span><br><span class="line"><span class="tag">          <span class="attr">case-order</span>=<span class="string">&#123;</span>&quot;<span class="attr">upper-first</span>&quot;|&quot;<span class="attr">lower-first</span>&quot;&#125;/&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="5-3-3-xsl-if"><a href="#5-3-3-xsl-if" class="headerlink" title="5.3.3 xsl:if"></a>5.3.3 xsl:if</h3><p>Q12：怎么使用if？</p>
<p>E12：</p>
<table><tr>
<td><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="if.jpg" border=0></td>
<td><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="if2.jpg" border=0></td>
</tr>
</table>

<p>C12：if通常与for-each搭配，根据条件输出所需要的文本或节点。</p>
<h3 id="5-3-4-xsl-choose-xsl-when-xsl-otherwise"><a href="#5-3-4-xsl-choose-xsl-when-xsl-otherwise" class="headerlink" title="5.3.4 xsl:choose xsl:when xsl:otherwise"></a>5.3.4 xsl:choose xsl:when xsl:otherwise</h3><p>E13：<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="switch.png" alt=""></p>
<h3 id="5-3-5-在输出中创建XML节点"><a href="#5-3-5-在输出中创建XML节点" class="headerlink" title="5.3.5 在输出中创建XML节点"></a>5.3.5 在输出中创建XML节点</h3><p>Q13：如何使用<strong>copy和copy-of</strong>？</p>
<p>E13：<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="创建元素.png" alt=""></p>
<p>C13：在上例中，递归的使用了xsl:copy，用于复制每一个节点到结果树中。而xsl:copy-of直接在文档入口处复制了根元素和下面的整棵树（包括属性和子元素）到结果树中，二者存在以下差异：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="copy.png" alt=""></p>
<p>缺点：xsl:copy 和 xsl:copy-of 可以将当前节点从源复制到输出，但是<strong>不能根据需要生成任意的 XML 节点</strong>。</p>
<p>Q14：如何使用<strong>element</strong>？</p>
<p>E14：<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="element.png" alt=""></p>
<p>C14：上例通过xsl:element,将源文档中的message元素<strong>改名</strong>为了new-message</p>
<p>Q15：如何使用<strong>attribute</strong>？</p>
<p>E15：<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="att.png" alt=""></p>
<p>C15：上例先通过copy复制了一个空的message元素，随后为其添加了属性content，并将原来message的文本内容赋给了content。</p>
<p>Q16：如何使用attribute-set？</p>
<p>E16：<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="set.png" alt=""></p>
<h3 id="5-3-6-如何控制输出格式？"><a href="#5-3-6-如何控制输出格式？" class="headerlink" title="5.3.6 如何控制输出格式？"></a>5.3.6 如何控制输出格式？</h3><p>E17：<code>&lt;xsl:output method=&quot;xml&quot; version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; indent=&quot;yes&quot;/&gt;</code></p>
<p>C17：这表示输出为XML格式，版本为XML1.0，编码方式为UTF-8<strong>并且进行缩进</strong>，<strong>如果不进行缩进，输出的会写在同一行</strong>，难以体现出层次关系。</p>
<h1 id="结"><a href="#结" class="headerlink" title="结"></a>结</h1><p>通过本次学习，我们学习到了XSLT的基本语法和其转换方式，在考试中<strong>XSLT常考于大题中</strong>，即给出原来的XML和XSLT让你<strong>写出转换后的XML文档</strong>。需要仔细学习规则，不然会失分很多。</p>
]]></content>
      <categories>
        <category>XML开发技术</category>
      </categories>
      <tags>
        <tag>课内学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>博客目录</title>
    <url>/2020/09/28/%E5%8D%9A%E5%AE%A2%E7%9B%AE%E5%BD%95/</url>
    <content><![CDATA[<div class="note success no-icon flat">
                            <p>
                                <strong>数据结构复习⭐</strong>
                            </p>
                            <table>
                                <thead>
                                    <tr>
                                        <th></th>
                                        <th></th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td>
                                            <a href="/2021/01/10/数据结构期中复习/">数据结构期中复习</a>
                                        </td>
                                        <td>
                                            <a href="/2021/01/03/数据结构期末复习/">数据结构期末复习</a>
                                        </td>
                                                                        </tr>
                            </tbody>
                        </table>
                    </div>


<div class="note success no-icon flat">
                            <p>
                                <strong>汇编语言复习⭐</strong>
                            </p>
                            <table>
                                <thead>
                                    <tr>
                                        <th></th>
                                        <th></th>
                                        <th></th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td>
                                            <a href="/2020/12/26/汇编语言总复习(上)/">汇编语言总复习(上)</a>
                                        </td>
                                        <td>
                                            <a href="/2020/12/26/汇编语言总复习(中)/">汇编语言总复习(中)</a>
                                        </td>
                                        <td>
                                            <a href="/2020/12/29/汇编语言总复习(下)/">汇编语言总复习(下)</a>
                                        </td>
                                         </tr>
                            </tbody>
                        </table>
                    </div>                               

<div class="note success no-icon flat">
                            <p>
                                <strong>XML学习笔记⭐</strong>
                            </p>
                            <table>
                                <thead>
                                    <tr>
                                        <th></th>
                                        <th></th>
                                        <th></th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td>
                                            <a href="/2020/11/14/XML开发技术——第一章/">XML开发技术——第一章</a>
                                        </td>
                                        <td>
                                            <a href="/2020/11/25/XML开发技术——第五章/">XML开发技术——第五章</a>
                                        </td>
                                        <td>
                                            <a href="/2021/01/02/XMLSPY考试应用/">XMLSPY考试应用</a>
                                        </td>
                                         </tr>
                            </tbody>
                        </table>
                    </div>      

<div class="note primary no-icon flat">
                            <p>
                                <strong>杂谈⭐</strong>
                            </p>
                            <table>
                                <thead>
                                    <tr>
                                        <th></th>
                                        <th></th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td>
                                            <a href="/2020/09/28/序/">序</a>
                                        </td>
                                        <td>
                                            <a href="/2021/01/12/紫罗兰永恒花园观后感/">紫罗兰永恒花园观后感</a>
                                        </td>
                                                                        </tr>
                            </tbody>
                        </table>
                    </div>]]></content>
  </entry>
  <entry>
    <title>序</title>
    <url>/2020/09/28/%E5%BA%8F/</url>
    <content><![CDATA[<p>很久之前就想拥有，在得知朋友尝试搭建了之后便立刻(不要脸)的索取了教程。会在这里记录一些心情和一些笔记（但愿）</p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构期中复习</title>
    <url>/2020/11/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<p>是时候面向考试复习一下数据结构了</p>
<p>本文只针对作者认为可能考到的知识点进行整理，存在不足，欢迎补充。</p>
<a id="more"></a>
<h1 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h1><h2 id="1-什么是数据结构"><a href="#1-什么是数据结构" class="headerlink" title="1.什么是数据结构"></a>1.什么是数据结构</h2><p>数据结构是相互之间存在一种或多种特定关系的数据元素的集合。</p>
<p>数据对象：即具有相同性质的数据元素的集合</p>
<p>例：英文字母数据对象：C={‘A’, ‘B’, ……, ‘Z’, ‘a’, ‘b’, ……, ‘z’}。</p>
<p>主要包括<strong>逻辑结构、存储结构</strong>和运算集合三部分。</p>
<p><strong>逻辑结构</strong>有四种：<strong>集合、线性结构、树形结构、图状结构（网状结构）</strong></p>
<p><strong>存储结构</strong>（也称为物理结构）有两种：<strong>顺序存储结构和链式存储结构</strong></p>
<p>顺序存储结构，是借助元素在存储器中的相对位置来表示数据之间逻辑关系，要求<strong>所有的元素依次放在一片连续空间中</strong>，通常借助程序设计语言的<strong>数组类型</strong>来描述。<br>链式存储结构<br>链式存储结构无需占用一整块存储空间。但为了表示结点之 间的关系， 需要给每个结点附加指针字段用于存放后继元素的储地址。所以链式结构通常借助程序设计语言<strong>指针类型</strong>来描述。</p>
<p>抽象数据类型的定义取决于数据类型的逻辑特性，<strong>与其在计算机内部如何表示和实现无关。</strong></p>
<p>两个重要特征：数据抽象性和数据封装性。</p>
<h4 id="例：试举一个数据结构的例子，叙述其逻辑结构和存储结构两方面的含义和相互关系。"><a href="#例：试举一个数据结构的例子，叙述其逻辑结构和存储结构两方面的含义和相互关系。" class="headerlink" title="例：试举一个数据结构的例子，叙述其逻辑结构和存储结构两方面的含义和相互关系。"></a>例：试举一个数据结构的例子，叙述其逻辑结构和存储结构两方面的含义和相互关系。</h4><p>答：例如有一张学生基本信息表，包括学生的学号、姓名、性别、籍贯、专业等。每个学生基本信息记录对应一个数据元素，学生记录按顺序号排列，形成了学生基本信息记录的线性序列。对于整个表来说，只有一个开始结点（它的前面无记录）和一个终端结点（它的后面无记录），其他的结点则各有一个也只有一个直接前趋和直接后继。<strong>学生记录之间的这种关系就确定了学生表的逻辑结构，即线性结构</strong>。<strong>这些学生记录在计算机中的存储表示就是存储结构。</strong>如果用连续的存储单元（如用数组表示）来存放这些记录，则称为顺序存储结构；如果存储单元不连续，而是随机存放各个记录，然后用指针进行链接，则称为链式存储结构。即相同的逻辑结构，可以对应不同的存储结构</p>
<h2 id="2-什么是算法"><a href="#2-什么是算法" class="headerlink" title="2.什么是算法"></a>2.什么是算法</h2><p>算法，简单来说就是解决问题的方法。它是规则的有限集合，是求解特定问题的过程描述、操作步骤或指令序列。</p>
<p>它具有5个重要特性：<strong>有穷性、确定性、可行性、输入、输出</strong></p>
<p><strong>算法时间复杂度的估算方法</strong>：</p>
<p>从算法中选取一种原操作(<strong>对于所研究的问题来说，该操作是基本操作</strong>)，将该操作重复执行的次数作为算法时间复杂度的衡量准则。</p>
<p><strong>时间复杂度与原操作的执行次数之和成正比。</strong></p>
<h1 id="第二章-表结构"><a href="#第二章-表结构" class="headerlink" title="第二章 表结构"></a>第二章 表结构</h1><h2 id="1-顺序表和链表"><a href="#1-顺序表和链表" class="headerlink" title="1.顺序表和链表"></a>1.顺序表和链表</h2><p>线性结构的逻辑结构特征：</p>
<p>​    (1)存在唯一的第1个数据元素；</p>
<p>　(2)存在唯一的最后1个数据元素；</p>
<p>　(3)第 i (&gt;1)个数据元素有唯一的1个前驱；</p>
<p>　(4)第 j (&lt;n)个数据元素有唯一的1个后继。</p>
<p><strong>顺序表：顺序存储结构：用位置描述逻辑关系</strong></p>
<p><strong>链表：链式存储结构：由指针描述逻辑关系</strong></p>
<p>补：链表的定义：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Type data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;Node,*LinkList;</span><br></pre></td></tr></table></figure>
<h4 id="例1：综合比较顺序表和链表"><a href="#例1：综合比较顺序表和链表" class="headerlink" title="例1：综合比较顺序表和链表"></a>例1：综合比较顺序表和链表</h4><p>答：顺序表在内存中是一段连续的存储空间， 通过头指针和偏移地址直接访问数据，访问数据的效率较高，为O（1），但是插入数据和删除数据的效率较低。<br> 链表在内存中是不连续的，通过每一个节点保存指向下一个节点的指针的方式来存储数据，访问数据的效率较低，但同时，插入数据和删除数据的效率较高。</p>
<h4 id="例2：解释链表的”头指针、头结点和首元素结点“三个概念"><a href="#例2：解释链表的”头指针、头结点和首元素结点“三个概念" class="headerlink" title="例2：解释链表的”头指针、头结点和首元素结点“三个概念"></a>例2：解释链表的”头指针、头结点和首元素结点“三个概念</h4><p>答：头指针：线性链表中第一个结点或头结点的存储地址，它是访问链表的起始点。</p>
<p>​        头结点：附加在第一个数据元素之前的结点，该结点的数据域一般为“空”、指针域存放第一个数据元素的地址。</p>
<p>​        首元素节点：链表中第一个存储着数据的节点。</p>
<h4 id="例3：给定链表的头指针L和一个正整数k。试设计一个尽可能高效的算法，用于查找链表L中倒数第k个位置上的结点。"><a href="#例3：给定链表的头指针L和一个正整数k。试设计一个尽可能高效的算法，用于查找链表L中倒数第k个位置上的结点。" class="headerlink" title="例3：给定链表的头指针L和一个正整数k。试设计一个尽可能高效的算法，用于查找链表L中倒数第k个位置上的结点。"></a>例3：给定链表的头指针L和一个正整数k。试设计一个尽可能高效的算法，用于查找链表L中倒数第k个位置上的结点。</h4><p>答：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">LinkSearch</span><span class="params">(ListList L,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k0=<span class="number">1</span>;</span><br><span class="line">    LinkList p=<span class="keyword">new</span> LinkList;</span><br><span class="line">    p=L-&gt;next;</span><br><span class="line">    LinkList q=p;</span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k0&lt;=k)++k0;</span><br><span class="line">        <span class="keyword">else</span> q=q-&gt;next;</span><br><span class="line">        </span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;<span class="comment">//时间复杂度为O(N)</span></span><br></pre></td></tr></table></figure>
<h2 id="2-栈与队列"><a href="#2-栈与队列" class="headerlink" title="2.栈与队列"></a>2.栈与队列</h2><p>我觉得期中考不了很难，鸽了（）</p>
<p>想了解的话请移步我朋友的博客：</p>
<p><a href="https://linyx.tk/2020/10/04/data-structure-study-note-1/">https://linyx.tk/2020/10/04/data-structure-study-note-1/</a></p>
<p>之后会补充（大概）</p>
<h2 id="3-递归"><a href="#3-递归" class="headerlink" title="3.递归"></a>3.递归</h2><p>递归的特点：</p>
<p>（1）出口至少有一个</p>
<p>（2）在经过有限次的递归调用后，能够导致递归出口的出现（<strong>递归算法必需具有终止递归的条件</strong>）</p>
<p>例：实现Hanoi塔问题</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hanoi</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">char</span> x,<span class="keyword">char</span> y,<span class="keyword">char</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">        move(x,<span class="number">1</span>,z);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        hanoi(n<span class="number">-1</span>,x,z,y);</span><br><span class="line">        move(x,n,z);</span><br><span class="line">        hanoi(n<span class="number">-1</span>,y,x,z);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="第三章：树结构"><a href="#第三章：树结构" class="headerlink" title="第三章：树结构"></a>第三章：树结构</h1><h2 id="1-树"><a href="#1-树" class="headerlink" title="1.树"></a>1.树</h2><p>树是有n个结点的有限集合（n&gt;=0)</p>
<p>树的结点包含一个数据元素以及若干个指针</p>
<p>结点拥有子树的个数称为<strong>结点的度</strong>。</p>
<p>度=0的结点叫做<strong>叶结点</strong></p>
<p>树的度=<strong>max(结点的度)</strong></p>
<p>结点的层次：第l层结点的孩子定义为l+1层。</p>
<p><strong>树的高度（深度）=max（结点的层次）</strong></p>
<h4 id="例：-已知一棵度为k的树中，有n1个度为1的结点，n2个度为2的结点，…，nk个度为k的结点。试计算该树的叶子结点数。"><a href="#例：-已知一棵度为k的树中，有n1个度为1的结点，n2个度为2的结点，…，nk个度为k的结点。试计算该树的叶子结点数。" class="headerlink" title="例： 已知一棵度为k的树中，有n1个度为1的结点，n2个度为2的结点，…，nk个度为k的结点。试计算该树的叶子结点数。"></a>例： 已知一棵度为k的树中，有n1个度为1的结点，n2个度为2的结点，…，nk个度为k的结点。试计算该树的叶子结点数。</h4><p>答：<strong>n0=1+0<em>n1+1</em>n2+2<em>n3+…+(K-1)</em>nK</strong></p>
<h2 id="2-二叉树"><a href="#2-二叉树" class="headerlink" title="2.二叉树"></a>2.二叉树</h2><p>二叉树：每个结点至多只有两棵子树</p>
<p>即：<strong>结点的度&lt;=2的有序树</strong></p>
<p>二叉树的定义：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Type data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TNode</span> *<span class="title">Lchild</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TNode</span> *<span class="title">Rchild</span>;</span></span><br><span class="line">&#125;TNode,*Tree;</span><br></pre></td></tr></table></figure>
<p>满二叉树：一棵高度为k且具有2^k-1个结点的二叉树</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="E:/myblog/Procrastination/source/_posts/图片1.png" alt="">（k=4)</p>
<p><strong>完全二叉树：高度为k，结点个数∈[2^(k-1),2^k-1]，且第k层结点都集中在左侧的二叉树。</strong></p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="E:/myblog/Procrastination/source/_posts/图片2.png" alt=""></p>
<h4 id="例：如果二叉树T的叶子结点数为n0，度为2的结点数为n2，则n0-n2-1。"><a href="#例：如果二叉树T的叶子结点数为n0，度为2的结点数为n2，则n0-n2-1。" class="headerlink" title="例：如果二叉树T的叶子结点数为n0，度为2的结点数为n2，则n0=n2+1。"></a>例：如果二叉树T的叶子结点数为n0，度为2的结点数为n2，则n0=n2+1。</h4><p>证明：</p>
<p>设二叉树T共有n个结点</p>
<p>度为0的结点数为n0，度为1的结点数为n1,度为2的结点数为n2，</p>
<p>T的分支数为m</p>
<p>（1）由于二叉树中所有结点的度&lt;=2,则：n=n0+n1+n2</p>
<p>（2）除根节点外，其余节点都有唯一前驱，则: n-1=m</p>
<p>（3）由于度=i（i=0，1，2）的结点具有i个分支，则：m=0+n1+2n2</p>
<p>联立上式得：n0=n2+1，证毕。</p>
<h2 id="3-二叉树的遍历"><a href="#3-二叉树的遍历" class="headerlink" title="3.二叉树的遍历"></a>3.二叉树的遍历</h2><h3 id="3-1-先序遍历"><a href="#3-1-先序遍历" class="headerlink" title="3.1 先序遍历"></a>3.1 先序遍历</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Tree T)</span><span class="comment">//递归写法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!T) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;T-&gt;data;</span><br><span class="line">    preOrder(T-&gt;Lchild);</span><br><span class="line">    preOrder(T-&gt;Rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Tree T)</span><span class="comment">//非递归写法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;Tree&gt; temp;</span><br><span class="line">    Tree p=T-&gt;Lchild;</span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;Lchild)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;p-&gt;data;</span><br><span class="line">            temp.push(p);</span><br><span class="line">            p=p-&gt;Lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;p-&gt;data;</span><br><span class="line">        <span class="keyword">while</span>(!p-&gt;Rchild)</span><br><span class="line">        &#123;</span><br><span class="line">            p=temp.top();</span><br><span class="line">            temp.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;Rchild)</span><br><span class="line">            p=p-&gt;Rchild;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="E:/myblog/Procrastination/source/_posts/图片3.png" alt=""></p>
<h3 id="3-2-中序遍历"><a href="#3-2-中序遍历" class="headerlink" title="3.2 中序遍历"></a>3.2 中序遍历</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(Tree T)</span><span class="comment">//递归写法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!T) <span class="keyword">return</span>;</span><br><span class="line">    InOrder(T-&gt;Lchild);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;T-&gt;data;</span><br><span class="line">    InOrder(T-&gt;Rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(Tree T)</span><span class="comment">//非递归写法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;Tree&gt; temp;</span><br><span class="line">    Tree p=T-&gt;Lchild;</span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;Lchild)</span><br><span class="line">        &#123;</span><br><span class="line">            temp.push(p);</span><br><span class="line">            p=p-&gt;Lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;p-&gt;data;</span><br><span class="line">        <span class="keyword">while</span>(!p-&gt;Rchild)</span><br><span class="line">        &#123;</span><br><span class="line">            p=temp.top();</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;p-&gt;data;</span><br><span class="line">            temp.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;Rchild)</span><br><span class="line">            p=p-&gt;Rchild;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="E:/myblog/Procrastination/source/_posts/image-20201107151715620.png" alt=""></p>
<h3 id="3-3-后序遍历"><a href="#3-3-后序遍历" class="headerlink" title="3.3 后序遍历"></a>3.3 后序遍历</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(Tree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!T) <span class="keyword">return</span> ;</span><br><span class="line">    PostOrder(T-&gt;Lchild);</span><br><span class="line">    PostOrder(T-&gt;Rchild);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;T-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(Tree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;Tree&gt; tempL，tempR;</span><br><span class="line">    Tree p=T-&gt;Lchild;</span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;Lchild)</span><br><span class="line">        &#123;</span><br><span class="line">            tempL.push(p);</span><br><span class="line">            p=p-&gt;Lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!p-&gt;Rchild)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;p-&gt;data;</span><br><span class="line">            <span class="keyword">while</span>(tempR.top()-&gt;Rchild==p)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;tempR.top()-&gt;data;<span class="comment">//获取R栈顶部指针的数据</span></span><br><span class="line">                tempR.pop();<span class="comment">//弹出</span></span><br><span class="line">            &#125;</span><br><span class="line">            p=tempL.top();</span><br><span class="line">            tempL.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;Rchild)</span><br><span class="line">        &#123;</span><br><span class="line">            tempR.push(p);</span><br><span class="line">            p=p-&gt;Rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="E:/myblog/Procrastination/source/_posts/image-20201107151732351.png" alt=""></p>
<h4 id="例：简述由先序序列和中序序列构造二叉树的基本操作方法"><a href="#例：简述由先序序列和中序序列构造二叉树的基本操作方法" class="headerlink" title="例：简述由先序序列和中序序列构造二叉树的基本操作方法"></a>例：简述由先序序列和中序序列构造二叉树的基本操作方法</h4><p>答：如果前序序列和中序序列都为空，那么构造一棵空树。否则</p>
<p>1、根据前序可确定根。</p>
<p>2、根据根和中序，可以确定左子树集合和右子树集合，并得到左子树中序序列和右子树中序序列。</p>
<p>3、在前序序列中划分出左子树前序序列和右子树前序序列。</p>
<p>4、根据左子树前序序列和左子树中序序列构造左子树。</p>
<p>5、根据右子树前序序列和右子树中序序列构造右子树。</p>
<h2 id="4-哈夫曼树"><a href="#4-哈夫曼树" class="headerlink" title="4.哈夫曼树"></a>4.哈夫曼树</h2><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="E:/myblog/Procrastination/source/_posts/image-20201107154325482.png" alt=""></p>
<h2 id="5-森林与二叉树的转换"><a href="#5-森林与二叉树的转换" class="headerlink" title="5.森林与二叉树的转换"></a>5.森林与二叉树的转换</h2><h3 id="5-1树转换为二叉树"><a href="#5-1树转换为二叉树" class="headerlink" title="5.1树转换为二叉树"></a>5.1树转换为二叉树</h3><p>（1）<strong>加虚线</strong> 在树的每层按从“左至右”的顺序<strong>在兄弟结点之间加虚线相连</strong><br>（2）去连线。<strong>除最左的第一个子结点</strong>外，父结点与所 其它子结点的连线都去掉<br>（3）旋转。将<strong>树顺时针旋转45°</strong>，原有的实线左斜<br>（4）整型。将旋转后树中的所有虛线改为实线，并向右斜。</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="E:/myblog/Procrastination/source/_posts/image-20201107155306011.png" alt="image-20201107155306011" style="zoom:67%;" /></p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="E:/myblog/Procrastination/source/_posts/image-20201107155341354.png" alt="image-20201107155341354" style="zoom: 67%;" /></p>
<h3 id="5-2二叉树转换成树"><a href="#5-2二叉树转换成树" class="headerlink" title="5.2二叉树转换成树"></a>5.2二叉树转换成树</h3><p>（1）加虚线  若某结点i是其父结点的左子树的根结点，<strong>则将该结点ⅰ的右子结点以及沿右子链不断地搜索所有的右子结点，将所有这些右子结点与i结点的父结点之间加虚线相连</strong></p>
<p>（2）去连线  去掉二叉树中所有其右子结点之间的连线<br>（3）规整化  将图中各结点按层次排列且将所有的虚线变成实线</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="E:/myblog/Procrastination/source/_posts/image-20201107155753914.png" alt="image-20201107155753914" style="zoom: 80%;" /></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>课内学习笔记</tag>
        <tag>考试复习整理</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构期末复习</title>
    <url>/2021/01/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<p>面向考试复习数据结构2.0版正式上线了</p>
<p>本文将整理后三章的相关知识点，并对例题习题进行整合梳理，存在不足，欢迎补充。</p>
<h1 id="第四章-图"><a href="#第四章-图" class="headerlink" title="第四章 图"></a>第四章 图</h1><h2 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h2><p>图是由一个顶点集V和一个弧集(或边集)构成的数据结构，是一种<strong>非线性</strong>数据结构</p>
<p>网：带权的图。<strong>在不会引起歧义时，网也直接称为图。</strong></p>
<p>路径长度：路径上边的数目（两个点之间的距离即路径上<strong>除了起点，包括终点的顶点个数</strong>）</p>
<p>简单路径：<strong>顶点不重复</strong>出现的路径（<strong>边可以重复</strong>）</p>
<h3 id="关于图的顶点和边数目"><a href="#关于图的顶点和边数目" class="headerlink" title="关于图的顶点和边数目"></a>关于图的顶点和边数目</h3><p> 我们用 n 表示图中顶点数目；m表示图中边(或者弧)的数目；</p>
<p>  对于无向图：<code>0≤m≤n(n-1)/2</code>  <strong>m=n(n-1)/2的无向图称为完全图</strong></p>
<p> 对于有向图：<code>0≤m≤n(n-1)</code>       <strong>m=n(n-1)的有向图称为有向完全图</strong></p>
<p>n=0: V为空集；<strong>m=0: 或许有1个顶点（平凡图）。</strong></p>
<p>例一：设某个非连通无向图有28条边，则该图至少有(9)个顶点。</p>
<p>解：此题的要点是<strong>非连通</strong>的无向图</p>
<p>由上方公式可得，8*7/2=28，正好为8个顶点的完全图的边数</p>
<p>但题目中要求是非连通的，所以在边不加的情况下，<strong>至少加一个孤立点，即至少有9个顶点</strong></p>
<p>举一反三：若某个连通无向图有28条边，则该图至少有(8)个顶点。</p>
<h3 id="关于图的度数"><a href="#关于图的度数" class="headerlink" title="关于图的度数"></a>关于图的度数</h3><p>什么是邻接点？</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="无向邻接点.png" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="有向邻接点.png" alt=""></p>
<p>什么是度数？</p>
<p>1.对于无向图，顶点v的度就是和顶点v相邻接的边的数目，<strong>记为TD(v)</strong></p>
<p>2.对于有向图，<strong>入度ID(v)</strong>是箭头指向v的弧的个数， <strong>出度OD(v)</strong>是箭头远离v的弧的个数</p>
<p>​                          顶点v的度<strong>TD(v)=ID(v)+OD(v)</strong></p>
<p>3.握手定理：</p>
<script type="math/tex; mode=display">
\begin{equation*}

2m = \sum_{n=1}^nTD(v_i)

\end{equation*}</script><h3 id="关于图的连通性"><a href="#关于图的连通性" class="headerlink" title="关于图的连通性"></a>关于图的连通性</h3><p>两个顶点间连通，等价于两个顶点之间有路径。</p>
<p>连通图：<strong>无向图</strong>中任意两个顶点都连通（<strong>不存在孤立点</strong>）</p>
<p>连通分量：无向图中的<strong>极大连通子图</strong></p>
<p>强连通图/强连通分量：<strong>对于有向图</strong>，概念类似上两个。</p>
<h3 id="生成树"><a href="#生成树" class="headerlink" title="生成树"></a>生成树</h3><p>对于<strong>连通图</strong>G，若其有n个顶点，则<strong>含有G中所有顶点，且边数为n-1</strong>的<strong>连通图</strong>称为G的一棵生成树。</p>
<p>关键：原图是连通图，生成树有其全部n个顶点，有且仅有n-1条边。</p>
<div class="note info flat"><p><strong>提示</strong></p>
    <p>有n个顶点和n-1条边的图不一定是生成树</p>
</div>

<p>在有n个顶点的图中,<strong>如果边多于n-1条,则一定有环</strong>，<strong>如果边少于n-1条,则是非连通图。</strong></p>
<h2 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h2><h3 id="图的邻接矩阵"><a href="#图的邻接矩阵" class="headerlink" title="图的邻接矩阵"></a>图的邻接矩阵</h3><h4 id="从邻接矩阵判断度数"><a href="#从邻接矩阵判断度数" class="headerlink" title="从邻接矩阵判断度数"></a>从邻接矩阵判断度数</h4><p>对于无向图，顶点Vi的度为邻接矩阵中第i行（或第i列）<strong>元素个数之和</strong>（防止带权干扰）。</p>
<p>对于有向图，第i<strong>行</strong>的元素个数之和为Vi的<strong>出度</strong>（从Vi到其他顶点）</p>
<p>​                       第i<strong>列</strong>的元素个数之和为Vi的<strong>入度</strong>（从其他顶点到Vi）</p>
<h4 id="时间复杂度和空间复杂度"><a href="#时间复杂度和空间复杂度" class="headerlink" title="时间复杂度和空间复杂度"></a>时间复杂度和空间复杂度</h4><p>用邻接矩阵存储图，占用的<strong>存储空间大小与顶点数有关，与边数无关</strong>。</p>
<p>时间复杂度为O(n²)</p>
<h3 id="图的邻接表"><a href="#图的邻接表" class="headerlink" title="图的邻接表"></a>图的邻接表</h3><p>概念定义：</p>
<p>邻接表是<strong>图的一种链式存储结构</strong>，图中的<strong>每一个顶点对应一个结点</strong>，并由所有顶点结点构成一个顺序表结构（竖着的链）</p>
<p>图中<strong>每一个顶点建立一条链，该链由它的所有邻接点构成</strong>（横着的链）</p>
<p>代码定义</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Anode</span></span></span><br><span class="line"><span class="class">&#123;</span>	<span class="keyword">int</span> Vi; <span class="comment">//邻接点在顺序表中的位置</span></span><br><span class="line">	<span class="keyword">int</span> Wi; <span class="comment">//权值(用于网。图可省略)</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Anode</span> *<span class="title">next</span>;</span> <span class="comment">//指向下一个邻接点</span></span><br><span class="line">&#125; ALink; <span class="comment">//邻接点存储结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Vnode</span></span></span><br><span class="line"><span class="class">&#123;</span>	Type data;</span><br><span class="line">	ALink *Vh; <span class="comment">//邻接点链表头指针</span></span><br><span class="line">&#125; Vnode; <span class="comment">//链表头指针结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span>	Vnode V [N];  <span class="comment">//链表头顺序表</span></span><br><span class="line">	<span class="keyword">int</span> n,m;  <span class="comment">//实际顶点数，边或弧数</span></span><br><span class="line">	<span class="keyword">int</span> visited[N];  <span class="comment">//访问标识</span></span><br><span class="line">&#125; AList; <span class="comment">//图的邻接表存储结构</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="从邻接表判断度数"><a href="#从邻接表判断度数" class="headerlink" title="从邻接表判断度数"></a>从邻接表判断度数</h4><p>无向图：顶点的度=邻接点链表中结点的数目</p>
<p>有向图：顶点的<strong>出度</strong>=邻接点链表中结点的数目</p>
<h4 id="时间复杂度和空间复杂度-1"><a href="#时间复杂度和空间复杂度-1" class="headerlink" title="时间复杂度和空间复杂度"></a>时间复杂度和空间复杂度</h4><p>用邻接表存储图，占用的<strong>存储空间大小与顶点数和边数都有关</strong>。</p>
<p>时间复杂度为O(n²)</p>
<h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><h4 id="深度优先搜索遍历-更适用于找一条路径"><a href="#深度优先搜索遍历-更适用于找一条路径" class="headerlink" title="深度优先搜索遍历(更适用于找一条路径)"></a>深度优先搜索遍历(<strong>更适用于找一条路径</strong>)</h4><p>基本思想：</p>
<p>①从图中某个顶点v出发，访问该顶点</p>
<p>②查找顶点v的第一个未被访问的邻接点v1，访问该顶点。</p>
<p>③重复第二步操作，直到图中没有未被访问的顶点为止。</p>
<h4 id="广度优先搜索遍历-更适用于找最优路径"><a href="#广度优先搜索遍历-更适用于找最优路径" class="headerlink" title="广度优先搜索遍历(更适用于找最优路径)"></a>广度优先搜索遍历(<strong>更适用于找最优路径</strong>)</h4><p>基本思想：</p>
<p>（1）从连通图中某个顶点v出发，访问该顶点，并置visited[v]的值为true，然后将v进队。</p>
<p>（2）只要队列不空，则重复下述处理：</p>
<p>​         ①队头顶点u出队</p>
<p>​         ②依次检查u的所有邻接点w，如果visited[w]的值为false，则访问w，并置visited[w]的值为true，然后将w进队。</p>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(AList G, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;	G.visited[N]=&#123;<span class="number">0</span>&#125;;	<span class="comment">//访问标识初始化</span></span><br><span class="line">	Visit(k);	<span class="comment">//访问顶点k（或者写cout&lt;&lt;k&lt;&lt;endl;也可以）</span></span><br><span class="line">	G.visited[k<span class="number">-1</span>]=<span class="number">1</span>;	<span class="comment">//顶点k已访问</span></span><br><span class="line">	f=<span class="number">0</span>,r=<span class="number">0</span>,Q[N]=&#123;<span class="number">0</span>&#125;; <span class="comment">//队列Q[]初始化</span></span><br><span class="line">	Q[r++]=k<span class="number">-1</span>;  <span class="comment">//入队, r:队尾指针</span></span><br><span class="line">	<span class="keyword">while</span>(r&gt;=f)	<span class="comment">//当队列非空时</span></span><br><span class="line">	&#123;	i=Q[f++];  <span class="comment">//出队, f:队首指针</span></span><br><span class="line">        p=G.V[i].Vh;<span class="comment">//p是V[i]的链表头指针</span></span><br><span class="line">		<span class="keyword">while</span>(p)<span class="comment">//顺序访问链表的各个结点</span></span><br><span class="line">		&#123;	</span><br><span class="line">            j=p-&gt;Vi; <span class="comment">// j是邻接点在顺序表中的位置</span></span><br><span class="line">			<span class="keyword">if</span>(!G.visited[j])</span><br><span class="line">			&#123;	Visit(j+<span class="number">1</span>); <span class="comment">//访问顶点j+1</span></span><br><span class="line">				visited[j]=<span class="number">1</span>;</span><br><span class="line">				Q[r++]=j; <span class="comment">//入队</span></span><br><span class="line">			&#125;</span><br><span class="line">          	p=p-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; <span class="comment">//算法结束</span></span><br></pre></td></tr></table></figure>
<p>以邻接表作存储结构时，深搜和广搜的时间复杂度都为O(n+e)</p>
<h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><p>定义：无向图G的所有生成树中各边权值之和最小的一颗生成树。</p>
<p>Prim算法：加点法</p>
<p>任取一个顶点v作为生成树的根，然后往生成树上添加新顶点u，顶点u满足其与生成树上某个顶点连通，并且在所有与生成树连通的边中权值最小，不断往生成树上添加顶点至生成树包含所有顶点为止。</p>
<p>K算法：加边法</p>
<p>为使生成树上边的权值之和达到最小，应使生成树中每一条边的权值尽可能地小(都能最小则最佳)。</p>
<p>例：请描述出用K算法得到最小生成树的步骤</p>
<p>①先构造一个只含n个顶点的子图S</p>
<p>②然后从权值最小的边开始，若它的添加不使S中产生回路，则在S上加上这条边</p>
<p>③如此重复，直至加上n-1条边为止。</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="最小生成树比较.png" alt=""></p>
<h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p>拓扑排序的一般操作方法：</p>
<p>(1)从有向图中选取一个入度为0的顶点，输出它;</p>
<p>(2)从有向图中删去该顶点以及所有以它为尾的弧;</p>
<p>重复上述两步，直至图空或者找不到入度为0的顶点为止。</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="拓扑排序.png" alt=""></p>
<p>时间复杂度为O(n+m)</p>
<h2 id="关键路径-从源点到汇点的最长路径"><a href="#关键路径-从源点到汇点的最长路径" class="headerlink" title="关键路径(从源点到汇点的最长路径)"></a>关键路径(<strong>从源点到汇点的最长路径</strong>)</h2><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="关键路径.png" alt=""></p>
<h1 id="第六章-排序"><a href="#第六章-排序" class="headerlink" title="第六章 排序"></a>第六章 排序</h1><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="排序.png" alt=""></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>课内学习笔记</tag>
        <tag>考试复习整理</tag>
      </tags>
  </entry>
  <entry>
    <title>汇编语言总复习(上)</title>
    <url>/2020/12/26/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E6%80%BB%E5%A4%8D%E4%B9%A0(%E4%B8%8A)/</url>
    <content><![CDATA[<p>本文将结合老师说的考试范围与PPT，对所涉及的知识点作个人总结，面向考试复习（<del>高星，yyds</del>）</p>
<p>顺序有点乱，如果有时间会再调一下。</p>
<a id="more"></a>
<h2 id="一、子程序与主程序"><a href="#一、子程序与主程序" class="headerlink" title="一、子程序与主程序"></a>一、子程序与主程序</h2><h3 id="（一）什么是子程序"><a href="#（一）什么是子程序" class="headerlink" title="（一）什么是子程序"></a>（一）什么是子程序</h3><p>把功能相对独立的程序段单独编写和调试，作为一个相对独立的模块供程序使用，就形成子程序</p>
<p>子程序可以实现源程序的模块化，可简化源程序结构，可以提高编程效率</p>
<p><strong>参数传递是子程序设计的重点和难点</strong></p>
<p>子程序的调用和返回是由指令<strong>CALL和RET</strong>(return)来完成的</p>
<p>•CALL指令分成4种类型（类似JMP）</p>
<p>CALL label ；段内调用、相对寻址</p>
<p>CALL r16/m16 ；段内调用、间接寻址</p>
<p><strong>CALL far ptr label ；段间调用、直接寻址</strong></p>
<p><strong>CALL far ptr mem ；段间调用、间接寻址</strong></p>
<p>返回时，RET直接从当前栈顶取内容作为返回地址。因此要保证RET指令执行前堆栈栈顶的内容刚好是返回的地址。</p>
<p>例：子程序的常见格式（实现回车换行的子程序）：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="子程序示例.png" alt=""></p>
<p>注意：</p>
<ol>
<li>对简化段定义格式，在tiny和small下，过程(PROC)的默认属性为near；对完整段定义格式下，过程的默认属性为near。</li>
<li>进行过程设计时，需要注意寄存器的保护和恢复，即<strong>开始时将要修改的寄存器内容压入栈，结束后再逆序弹出</strong>。</li>
</ol>
<h3 id="（二）如何进行参数传递"><a href="#（二）如何进行参数传递" class="headerlink" title="（二）如何进行参数传递"></a>（二）如何进行参数传递</h3><p>主程序在调用子程序时，通常需要提供一些数据，即<strong>入口参数（输入参数）</strong></p>
<p>子程序执行结束后要返回主程序数据，即<strong>出口参数（输出参数）</strong></p>
<p>参数的形式分为两种</p>
<p>① 数据本身（传值）②数据的地址（传址）</p>
<p>下面介绍如何传递参数</p>
<h4 id="1-寄存器传递参数（共享寄存器）"><a href="#1-寄存器传递参数（共享寄存器）" class="headerlink" title="1.寄存器传递参数（共享寄存器）"></a>1.寄存器传递参数（共享寄存器）</h4><p>把参数存于约定的寄存器中，可以传值，也可以传址。</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="寄存器传参.png" alt=""></p>
<p>上图的子程序将和存在了al中，返回后再将其mov到result中，实现了参数传递。</p>
<p>注:子程序对带有入口参数的寄存器可以保护，也可以不保护；上图未保护</p>
<p>​     子程序对带有出口参数的寄存器不能保护和恢复</p>
<h4 id="2-变量传递参数（共享变量）"><a href="#2-变量传递参数（共享变量）" class="headerlink" title="2.变量传递参数（共享变量）"></a>2.变量传递参数（共享变量）</h4><p>主程序和子程序直接采用同一个变量名共享同一个变量。</p>
<p>类比于C++中的加引用，<strong>直接改变了变量的值</strong>。</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="变量传参1.png" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="变量传参2.png" alt=""></p>
<p>上图的子程序直接将al中的值mov到了result，随后返回到主程序。</p>
<h4 id="3-堆栈传递参数（共享堆栈）"><a href="#3-堆栈传递参数（共享堆栈）" class="headerlink" title="3.堆栈传递参数（共享堆栈）"></a>3.堆栈传递参数（共享堆栈）</h4><p>主程序将子程序的入口参数压入堆栈，子程序从堆栈中取出参数</p>
<p>子程序将出口参数压入堆栈，主程序弹出堆栈取得它们</p>
<p>前方高能</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="堆栈传参1.png" alt=""></p>
<p>入口参数为数组的偏移地址和数组的元素个数，通过压入堆栈进行传递。</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="堆栈传参2.png" alt=""></p>
<p>程序在保护bp后，将bp置为栈顶，并通过偏移位置来分别寻址获得压入的偏移地址和元素参数。最后按反序弹出栈内值和址。</p>
<p>上述程序堆栈的使用情况如下图</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="堆栈情况.png" alt=""></p>
<p>由于<strong>主程序压入了2个参数，使用了堆栈区的4字节</strong>，故采用上述办法平衡堆栈。</p>
<p>注：由于寄存器的保护也存于堆栈中，所以在子程序退出时<strong>要特别注意pop的顺序</strong>。</p>
<h2 id="二、缓冲区"><a href="#二、缓冲区" class="headerlink" title="二、缓冲区"></a>二、缓冲区</h2><h3 id="（一）如何定义缓冲区"><a href="#（一）如何定义缓冲区" class="headerlink" title="（一）如何定义缓冲区"></a>（一）如何定义缓冲区</h3><p>例</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="缓冲区定义.png" alt=""></p>
<p>该例表示在内存中申请一个<strong>缓冲区为83个字节，首地址给BUF</strong>。</p>
<p>缓冲区分为<strong>三个部分</strong></p>
<p>第一个字节内放的是<strong>事先填入最多欲接收的字符个数</strong>（包括回车字符，可以是1～255），在例中为81，表示申请的存放数据的缓冲区的字节数为81个。</p>
<p>第二个字节 ‘ ？‘表示的是实际存放的字节个数（不包括回车）</p>
<p>就是说，你放入2个字节的数据，“？”变成2，放10个字节的数据，变成10）；</p>
<p>DB表示的是分配一个或多个字节；</p>
<p><strong>输入的数据（字符串）从第三个字节开始存放</strong>，存放至第82个字节，<strong>第81个字节存放回车符（0DH）,0DH作为输入数据的结束</strong>。</p>
<p><strong>DUP(0)</strong>表示的是<strong>存放数据的81个字节初始值全为0</strong>，即为：81 0 0 0 0······（第82个字节）0 ODH。</p>
<p>注：实际输入的字符数多于定义数时，多出的字符丢掉，且响铃</p>
<h3 id="（二）如何使用缓冲区"><a href="#（二）如何使用缓冲区" class="headerlink" title="（二）如何使用缓冲区"></a>（二）如何使用缓冲区</h3><p>下例实现了字符串的输入</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="字符串输入.png" alt=""></p>
<h2 id="三、串操作指令"><a href="#三、串操作指令" class="headerlink" title="三、串操作指令"></a>三、串操作指令</h2><p>串操作指令的操作对象是以字（W）为单位的<strong>字串</strong>，或是以字节（B）为单位的<strong>字节串</strong></p>
<p>串操作指令采用了特殊的寻址方式</p>
<ol>
<li>源操作数用寄存器SI间接寻址，默认在数据段DS中，即DS:[DI]</li>
<li><strong>目的操作数用寄存器DI间接寻址，默认在附加段ES中</strong>，即ES:[SI]</li>
<li>每执行一次串操作，SI和DI将自动修改</li>
<li><strong>源数据串可以段跨越，目的串不可。</strong></li>
</ol>
<p>注：由于要自动修改SI与DI，所以用户需要在进行串操作之前<strong>改变方向标志DF先确定增加或减小的方向</strong></p>
<p>即：执行<strong>CLD</strong>（DF=0，主存地址增大，<strong>较为常用</strong>）或执行STD（DF=1，主存地址减小）</p>
<p>串操作经出<strong>配合重复前缀指令</strong>，通过<strong>计数器CX</strong>控制重复执行串操作指令的次数。</p>
<h3 id="（一）串传送指令"><a href="#（一）串传送指令" class="headerlink" title="（一）串传送指令"></a>（一）串传送指令</h3><p>①串传送 MOVSB/W（move string）</p>
<p>把字节从主存的源地址传送至目标地址</p>
<p><strong>MOVSB</strong> 字节串传送：<strong>ES:[DI]←DS:[SI]</strong></p>
<p>②串存储 STOSB/W（store string）</p>
<p>把<strong>AL或AX</strong>数据传送至目标地址</p>
<p><strong>STOSB</strong>  字节串存储：<strong>ES:[DI]←AL</strong>（AL传字节）</p>
<p><strong>STOSW</strong> 字串存储：    <strong>ES:[DI]←AX</strong>（AX传字）</p>
<p>③串读取 LODSB/W（load string）</p>
<p>把指定主存单元的数据传送给<strong>AL或AX</strong></p>
<p><strong>LODSB</strong>  字节串读取： <strong>AL←DS:[SI]</strong></p>
<p><strong>LODSW</strong> 字串读取：    <strong>AX←DS:[SI]</strong></p>
<p>④REP重复前缀指令</p>
<p><strong>REP</strong> <strong>；每执行一次串指令，CX减1直到CX＝0</strong>，重复执行结束</p>
<p>即：当数据串没有结束（CX≠0），则继续传送</p>
<h3 id="（二）串检测指令"><a href="#（二）串检测指令" class="headerlink" title="（二）串检测指令"></a>（二）串检测指令</h3><p>①串比较指令CMPS（compare string）</p>
<p>将主存中的<strong>源操作数减去至目的操作数</strong>，以便设置标志，进而比较两操作数之间的关系</p>
<p><strong>CMPSB</strong>  字节串比较：<strong>DS:[SI]－ES:[DI]</strong></p>
<p>②串扫描SCAS（scan string）</p>
<p>将<strong>AL/AX减去至目的操作数</strong>，以便设置标志，进而比较AL/AX与操作数之间的关系</p>
<p><strong>SCASB</strong>  字节串扫描：<strong>AL－ES:[DI]</strong></p>
<p><strong>SCASW</strong> 字串扫描：   <strong>AX－ES:[DI]</strong></p>
<p>③REPZ/REPE重复前缀指令</p>
<p>每执行一次串指令，CX减1并判断ZF是否为0，</p>
<p>只要CX＝0或ZF＝0，重复执行结束。</p>
<p>即：当数据串没有结束（CX≠0），<strong>并且串相等（ZF＝1），则继续比较</strong></p>
<p>④REPNZ/REPNE重复前缀指令</p>
<p>每执行一次串指令，CX减1并判断ZF是否为0，</p>
<p>只要CX＝0或ZF＝0，重复执行结束。</p>
<p>即：当数据串没有结束（CX≠0），<strong>并且串不相等（ZF＝0），则继续比较</strong></p>
<p>REPNZ和LOOP的区别：</p>
<p>REPNZ是先执行一次指令，之后将CX减一，判断CX是否为0。</p>
<p>而LOOP是先将CX减一，然后判断CX是否为0，不为0则继续执行指令。</p>
<p>例：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="比较字符串.png" alt=""></p>
<p>在上例中，指令repz cmpsb结束有两种情况</p>
<p>第一种：ZF=0，即<strong>出现不相等的字符</strong></p>
<p>第二种：CX=0，即<strong>比较完了所有字符</strong></p>
<p>注意，在这种情况下，<strong>如果ZF=0，则说明最后一个字符不相等，ZF=1才能说明两个字符串相同</strong>。</p>
<p>所以，重复比较结束后，需要通过<strong>jnz</strong>指令 来判断<strong>zf位</strong>，若其=0，则字符串不相等。</p>
<p>总流程图如下</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="串操作流程图.png" alt=""></p>
<p>下例为SCAS在字符串中查找空格字符的用法</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="查找空格.png" alt=""></p>
<h2 id="四、常用DOS命令"><a href="#四、常用DOS命令" class="headerlink" title="四、常用DOS命令"></a>四、常用DOS命令</h2><p>调用DOS功能一般方法如下：</p>
<p>1、在<strong>AH寄存器</strong>中设置系统功能调用号，说明选择的功能</p>
<p>2、在指定寄存器中设置入口参数。</p>
<p>3、用中断调用指令 INT 21H 执行功能调用。</p>
<h3 id="（一）字符输出（02H号）"><a href="#（一）字符输出（02H号）" class="headerlink" title="（一）字符输出（02H号）"></a>（一）字符输出（02H号）</h3><p>入口参数：<strong>DL</strong>=字符的ASCII码</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="字符输出.png" alt=""></p>
<p>注：该功能可以识别响铃字符（07H），回车（0DH），换行（0AH）。</p>
<h3 id="（二）字符串输出（09H号）"><a href="#（二）字符串输出（09H号）" class="headerlink" title="（二）字符串输出（09H号）"></a>（二）字符串输出（09H号）</h3><p>入口参数：<strong>DS:DX</strong>=欲显示字符串在主存中的首地址。</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="字符串输出.png" alt=""></p>
<p>注：顺序为先回车（0DH），再换行（0AH），且字符串应以’$’(24H)结束。</p>
<h3 id="（三）字符输入（01H号）"><a href="#（三）字符输入（01H号）" class="headerlink" title="（三）字符输入（01H号）"></a>（三）字符输入（01H号）</h3><p>出口参数：<strong>AL</strong>=字符的ASCII码</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="字符输入.png" alt=""></p>
<p>调用此功能时，若无键按下，则会一直等待，直到按键后才读取该键值</p>
<h3 id="（四）字符串输入（0AH号）"><a href="#（四）字符串输入（0AH号）" class="headerlink" title="（四）字符串输入（0AH号）"></a>（四）字符串输入（0AH号）</h3><p>入口参数：<strong>DS:DX</strong>=缓冲区首地址</p>
<p><strong>关键要定义好缓冲区</strong></p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="字符串输入.png" alt=""></p>
<h2 id="五、8086的机器代码格式"><a href="#五、8086的机器代码格式" class="headerlink" title="五、8086的机器代码格式"></a>五、8086的机器代码格式</h2><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="机器代码.png" alt=""></p>
<p>机器码我都不怎么懂，直接搬PPT了= =</p>
<p>例1： </p>
<p>MOV AX,BX ;机器代码是 89 D8(16进制)</p>
<p>第1个字节89是操作码(含<strong>w＝1表示16位操作</strong>)</p>
<p>第2个字节D8（11 011 000）是 “<strong>mod reg r/m</strong>”</p>
<p>reg＝011表示目的操作数为BX</p>
<p>mod＝11时，为<strong>寄存器寻址方式</strong>。</p>
<p>mod＝11和r/m＝000表示源操作数为AX</p>
<p>例2：</p>
<p>MOV AL,[BX+SI+6] ;机器代码是 8A 40（16进制） 06</p>
<p>前一个字节8A是操作码(含<strong>w＝0表示8位操作</strong>)</p>
<p>中间一个字节40（01 000 000）(将16进制转为2进制，然后按2 3 3拆开)是 “<strong>mod reg r/m</strong>”字节</p>
<p>reg＝000表示目的操作数为AL</p>
<p>mod＝01时，为<strong>带有8位位移量的存储器寻址方式</strong></p>
<p>mod＝01和r/m＝000表示源操作数为[BX+SI+D8]</p>
<p>最后一个字节就是8位位移量[D8]=06</p>
<h2 id="六、常用的ASCII码"><a href="#六、常用的ASCII码" class="headerlink" title="六、常用的ASCII码"></a>六、常用的ASCII码</h2><p><strong>回车：0DH    换行：0AH</strong>   响铃：07H</p>
<p><strong>空格：20H</strong></p>
<p><strong>数字0~9：30H~39H</strong></p>
<p>大写字母A~Z：41H~5AH</p>
<p>小写字母a~z：61H~7AH</p>
<h2 id="七、BCD码"><a href="#七、BCD码" class="headerlink" title="七、BCD码"></a>七、BCD码</h2><p>Binary Coded Decimal（二进制编码的十进制数），即<strong>一个十进制数位（0-9）在计算机中用4位二进制编码表示</strong>。常用的BCD码是8421BCD码，即用4位二进制编码的低19个编码表示0-9这十个数字，如图。</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="BCD码.png" alt=""></p>
<p>例：0100 1001 0111 1000.0001 0100 1001  十进制真值：4978.149（上图对应）</p>
<p>00111010B=3AH   F2H=11110010B</p>
<p>10H=00010000B=16D                        ABH=10101011B=171D</p>
<p>压缩BCD码：一个字节表达两位BCD码      10000111B（87H)</p>
<p>非压缩BCD码：<strong>一个字节表达一位BCD码</strong>（<strong>低4位表达数值，高4位常设置为0</strong>）   </p>
<p>00001000 00000111B（0807H）</p>
<h2 id="八、变量的定义"><a href="#八、变量的定义" class="headerlink" title="八、变量的定义"></a>八、变量的定义</h2><h3 id="（一）符号常数"><a href="#（一）符号常数" class="headerlink" title="（一）符号常数"></a>（一）符号常数</h3><p>利用一个标识符表达的一个数值</p>
<p>例：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="符号常数.png" alt=""></p>
<p>注：在5.x版本中，<strong>字符串是用引号括起来的</strong></p>
<p>例：<code>calldos  equ &quot;int 21h&quot;</code></p>
<p>EQU用于数值等价时不能重复定义符号名,<strong>但”=“允许有重复赋值</strong></p>
<p>X=7  X EQU 7 都是正确的</p>
<p>X=X+5   但 X EQU X+5是错误的</p>
<h3 id="（二）变量定义伪指令"><a href="#（二）变量定义伪指令" class="headerlink" title="（二）变量定义伪指令"></a>（二）变量定义伪指令</h3><p>变量定义（Define）伪指令为变量申请固定长度的存储空间，并可同时将相应的存储单元初始化</p>
<p>其汇编格式为：<code>变量名    伪指令    初值表</code></p>
<p>变量名：</p>
<ol>
<li>变量名为用户自定义标识符，<strong>表示初值表首元素的逻辑地址</strong>；用这个符号表示地址，<strong>常称为符号地址</strong></li>
<li>变量名可以没有，此时无符号地址。</li>
</ol>
<p>初值表：</p>
<ol>
<li><p>初值表是用逗号分隔的参数</p>
</li>
<li><p>主要由数值常数、表达式或？、DUP组成</p>
<p>？——表示初值不确定，即未赋初值</p>
<p>DUP——表示重复初值</p>
<p><strong>DUP的格式为：重复次数 DUP(重复参数)</strong></p>
</li>
</ol>
<h3 id="（三）定义实例"><a href="#（三）定义实例" class="headerlink" title="（三）定义实例"></a>（三）定义实例</h3><p>1.字节单元定义实例</p>
<p>DB伪指令用于分配一个或多个字节单元。初值表中每个数据一定是字节量（Byte），存放8位数据。</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="字节单元定义.png" alt=""></p>
<p>2.字单元定义实例</p>
<p>DW伪指令用于分配一个或多个字单元。初值表中每个数据一定是字量（Word），存放16位数据。</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="字单元.png" alt=""></p>
<p>3.字变量和字常量的应用（重要）</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="字变量与字常量.png" alt=""></p>
<p>即：字变量在程序中当作mem，即取其偏移地址元素的数值。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>只花了一天的时间去复习整理汇编语言，希望别挂科就好</p>
<p>后面看到这篇的人一定要好好学汇编啊。</p>
<p>张海英你没有心（确信）</p>
]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
      <tags>
        <tag>课内学习笔记</tag>
        <tag>考试复习整理</tag>
      </tags>
  </entry>
  <entry>
    <title>汇编语言总复习(下)</title>
    <url>/2020/12/29/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E6%80%BB%E5%A4%8D%E4%B9%A0(%E4%B8%8B)/</url>
    <content><![CDATA[<p>下篇主要是临考试的挣扎，挑了一些觉得可能会考的用来押题，希望全都考到</p>
<p>孩子哭了，汇编一定要好好学啊</p>
<a id="more"></a>
<h2 id="选择题："><a href="#选择题：" class="headerlink" title="选择题："></a>选择题：</h2><h3 id="例一：下列语句没错的是："><a href="#例一：下列语句没错的是：" class="headerlink" title="例一：下列语句没错的是："></a>例一：下列语句没错的是：</h3><p>MOV AL，050AH</p>
<p>MOV [SI],0AH</p>
<p>MOV DS,100H</p>
<p>MOV CS,[SI]</p>
<p>MOV DS,ES</p>
<p>答：都有错，这题不选（</p>
<p>第一句中，AL表示字节，而050AH单位为字，目的操作数与源操作数的类型不一，故错。</p>
<p>第二句中，存储器单元与立即数同时作为操作数，但是没有显式指明类型，故错</p>
<p>更正：<strong>MOV BYTE PTR [SI],0AH (字节操作)</strong></p>
<p>第三句中，立即数不能直接送到段寄存器中，故错。</p>
<p>第四句中，CS是专用寄存器，碰不得</p>
<p>第五句中，段寄存器之间不能相互传递，故错。</p>
<h3 id="例二：下列语句等值的是："><a href="#例二：下列语句等值的是：" class="headerlink" title="例二：下列语句等值的是："></a>例二：下列语句等值的是：</h3><h2 id="简答题："><a href="#简答题：" class="headerlink" title="简答题："></a>简答题：</h2><h3 id="例一：解释TEST和AND指令的异同，并说明其使用注意点"><a href="#例一：解释TEST和AND指令的异同，并说明其使用注意点" class="headerlink" title="例一：解释TEST和AND指令的异同，并说明其使用注意点"></a>例一：解释TEST和AND指令的<strong>异同</strong>，并说明其使用注意点</h3><p>答：相同点：TEST和AND指令属于逻辑运算指令，<strong>对两个操作数进行按位的逻辑与运算</strong>，且均<em>设置CF=OF=0</em>，对AF无定义。</p>
<p>​       不同点：AND指令会将逻辑与的结果送给目的操作数，而TEST指令不会。</p>
<p>举一反三.1：解释TEST和CMP指令的异同</p>
<p>答：相同点：TEST指令和CMP指令都不会将结果送回给操作数，只修改标志位。</p>
<p>​        test<strong>逻辑与（AND）运算结果为零</strong>,就把ZF(零标志)置1;</p>
<p>​        cmp <strong>算术减法运算（SUB）结果为零</strong>,就把ZF(零标志)置1.</p>
<p>​        不同点：TEST指令是<strong>逻辑运算符</strong>，对两个操作数进行按位的逻辑与运算，</p>
<p>​                       而CMP指令是<strong>算术运算指令</strong>，将<strong>目的操作数减去源操作数（后减前）</strong></p>
<h3 id="例二：画图并解释说明MOV指令在立即数、通用寄存器、段寄存器和存储器之间可能转移关系，并写出将立即数0102H放入DS寄存器的代码"><a href="#例二：画图并解释说明MOV指令在立即数、通用寄存器、段寄存器和存储器之间可能转移关系，并写出将立即数0102H放入DS寄存器的代码" class="headerlink" title="例二：画图并解释说明MOV指令在立即数、通用寄存器、段寄存器和存储器之间可能转移关系，并写出将立即数0102H放入DS寄存器的代码"></a>例二：<strong>画图并解释说明</strong>MOV指令在立即数、通用寄存器、段寄存器和存储器之间可能转移关系，并写出将立即数0102H<strong>放入DS寄存器</strong>的代码</h3><p>答：<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="MOV图.png" alt=""></p>
<p><code>MOV AX,0102H</code></p>
<p><code>MOV DS,AX</code></p>
<p>解释说明：</p>
<p>1.立即数到存储器和寄存器<strong>都是单向的</strong>。</p>
<p>2.<strong>立即数不能直接到段寄存器</strong>，需要通过寄存器中转</p>
<p>3.寄存器之间可以互相mov</p>
<p>4.<strong>段寄存器之间不能互相传递</strong></p>
<p>5.<strong>存储器之间不能相互传递</strong></p>
<p>举一反三.2：写出交换将BUF1段中的数据和BUF2段中数据的代码</p>
<p>答：</p>
<p><code>MOV AX,BUF1</code></p>
<p><code>MOV DX,BUF2</code></p>
<p><code>MOV BUF2,AX</code></p>
<p><code>MOV BUF1,DX</code></p>
<h3 id="例三：8086有多少种存储器寻址方式？写出相对基址变址寻址方式的公式并解释何为变址。"><a href="#例三：8086有多少种存储器寻址方式？写出相对基址变址寻址方式的公式并解释何为变址。" class="headerlink" title="例三：8086有多少种存储器寻址方式？写出相对基址变址寻址方式的公式并解释何为变址。"></a>例三：8086有多少种存储器寻址方式？写出相对基址变址寻址方式的公式并解释何为变址。</h3><p>答：一共有五种</p>
<p>分别为：</p>
<p>1.直接寻址 ：MOV AX,[2077H]</p>
<p>2.寄存器间接寻址 ：MOV AX,[SI]</p>
<p>3.寄存器相对寻址：MOV AX,[SI+06H]</p>
<p>4.基址变址寻址方式：MOV AX,[BX+SI]</p>
<p>5.相对基址变址寻址：MOV AX,[BX+SI+06H]</p>
<p>解释：<strong>基址是指基址寄存器（BX/BP），变址是指变址寄存器（SI/DI）</strong></p>
<p>相对基址变址寻址，即使用基址寄存器和变址寄存器，再加上一个8/16位的<strong>位移量（即为相对）</strong>，<strong>这三者之和构成操作数的有效地址EA</strong></p>
<h3 id="例四：什么是8086中的逻辑地址和物理地址？逻辑地址如何转换成物理地址-？"><a href="#例四：什么是8086中的逻辑地址和物理地址？逻辑地址如何转换成物理地址-？" class="headerlink" title="例四：什么是8086中的逻辑地址和物理地址？逻辑地址如何转换成物理地址 ？"></a>例四：什么是8086中的逻辑地址和物理地址？逻辑地址如何转换成物理地址 ？</h3><p>答：<strong>”段地址：偏移地址“被称为逻辑地址</strong>。其中段地址说明逻辑段在主存中的起始位置，偏移地址说明主存单元距离段起始位置的偏移量。</p>
<p>物理地址：在8086中，每个存储器单元都有一个20位的地址，被称为 单元的物理地址，也为实际地址。<strong>（默认要补齐5位）</strong>如图</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="逻辑地址转化.png" alt=""></p>
<h3 id="例五：编写定义缓冲区，及实现输入字符串的核心代码"><a href="#例五：编写定义缓冲区，及实现输入字符串的核心代码" class="headerlink" title="例五：编写定义缓冲区，及实现输入字符串的核心代码"></a>例五：编写定义缓冲区，及实现输入字符串的核心代码</h3><p>答：<code>string db &#39;Im a string&#39;,0dh,0ah,&#39;$&#39;</code></p>
<p><code>buffer  db 81</code></p>
<pre><code>         `db ?`

         `db 81 dup(0)`
</code></pre><p><code>mov dx,seg buffer</code></p>
<p><code>mov ds,dx</code></p>
<p><code>mov ah,0ah</code></p>
<p><code>mov dx,offset buffer</code></p>
<p><code>int 21h</code></p>
<h2 id="编程题"><a href="#编程题" class="headerlink" title="编程题"></a>编程题</h2><h3 id="例一：编写一个程序，要求能从键盘接收一个个位数N，然后响铃N-次-响铃的ASCII-码为07"><a href="#例一：编写一个程序，要求能从键盘接收一个个位数N，然后响铃N-次-响铃的ASCII-码为07" class="headerlink" title="例一：编写一个程序，要求能从键盘接收一个个位数N，然后响铃N 次(响铃的ASCII 码为07)"></a>例一：编写一个程序，要求能从<strong>键盘接收</strong>一个个位数N，然后<strong>响铃N</strong> 次(响铃的ASCII 码为07)</h3><p>分析：采用字符串输入功能接受一个数，传入CX中，再调用输出字符功能，输出直到CX为0</p>
<p>代码如下：</p>
<p><code>.model small</code></p>
<p><code>.stack</code></p>
<p><code>.data</code></p>
<p><code>.code</code></p>
<p><code>.startup</code></p>
<p><code>mov ah,01h</code></p>
<p><code>int 21h</code></p>
<p><code>sub al,30h</code></p>
<p><code>mov cl,al</code></p>
<p><code>mov ah,02h</code></p>
<p><code>mov dl,0ah</code></p>
<p><code>int 21h</code></p>
<p><code>again:</code></p>
<p>​    <code>cmp cl,0</code></p>
<p>​    <code>jz over</code></p>
<p>​    <code>mov ah,02h</code></p>
<p>​    <code>mov dl,07h</code></p>
<p>​    <code>int 21h</code></p>
<p>​    <code>mov dl,&#39;1&#39;</code></p>
<p>​    <code>int 21h</code></p>
<p>​    <code>dec cl</code></p>
<p>​    <code>jmp again</code></p>
<p><code>over: .exit 0</code></p>
<p>​        <code>end</code></p>
<h3 id="例二：实现字符串的冒泡排序"><a href="#例二：实现字符串的冒泡排序" class="headerlink" title="例二：实现字符串的冒泡排序"></a>例二：实现字符串的冒泡排序</h3><p>分析：使用两层循环，结合跳转实现</p>
<p>代码如下：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="代码.png" alt=""></p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>明天上刑场</p>
<p>概统还没复习</p>
<p>高星救我</p>
]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
      <tags>
        <tag>课内学习笔记</tag>
        <tag>考试复习整理</tag>
      </tags>
  </entry>
  <entry>
    <title>汇编语言总复习(中)</title>
    <url>/2020/12/26/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E6%80%BB%E5%A4%8D%E4%B9%A0(%E4%B8%AD)/</url>
    <content><![CDATA[<p>本文将结合老师说的考试范围与PPT，对所涉及的知识点作个人总结，面向考试复习（<del>高星，yyds</del>）</p>
<p>为了网页加载快一点将文章分开发了</p>
<p>实在是太多了</p>
<a id="more"></a>
<h2 id="九、MOV指令总结"><a href="#九、MOV指令总结" class="headerlink" title="九、MOV指令总结"></a>九、MOV指令总结</h2><h3 id="（一）立即数传送（MOV-reg-mem-imm）"><a href="#（一）立即数传送（MOV-reg-mem-imm）" class="headerlink" title="（一）立即数传送（MOV reg/mem,imm）"></a>（一）立即数传送（MOV reg/mem,imm）</h3><p>例：MOV CX,0FFH (字传送)</p>
<p><strong>MOV BYTE PTR [SI],0AH (字节操作)</strong></p>
<p><strong>MOV WORD PTR [SI+2],0BH(字操作)</strong></p>
<p>即：立即数可以传到<strong>寄存器和存储器</strong>中</p>
<h3 id="（二）寄存器传送（MOV-reg-mem-seg-reg）"><a href="#（二）寄存器传送（MOV-reg-mem-seg-reg）" class="headerlink" title="（二）寄存器传送（MOV reg/mem/seg,reg）"></a>（二）寄存器传送（MOV reg/mem/seg,reg）</h3><p>例：MOV AX,BX</p>
<p>​       MOV AH,AL</p>
<p>​       MOV DS,AX</p>
<p>​       MOV [BX],AL</p>
<p>即：寄存器可以传到<strong>寄存器、存储器和段寄存器</strong>中。</p>
<h3 id="（三）存储器传送（MOV-reg-seg-mem）"><a href="#（三）存储器传送（MOV-reg-seg-mem）" class="headerlink" title="（三）存储器传送（MOV reg/seg,mem）"></a>（三）存储器传送（MOV reg/seg,mem）</h3><p>例：MOV AL,[BX]</p>
<p>​        MOV DX,[BP]</p>
<p>​        MOV ES,[SI]</p>
<p>注：<strong>不存在存储器向存储器的传送</strong>（除串操作）</p>
<h3 id="（四）段寄存器传送（MOV-reg-mem-seg）"><a href="#（四）段寄存器传送（MOV-reg-mem-seg）" class="headerlink" title="（四）段寄存器传送（MOV reg/mem,seg）"></a>（四）段寄存器传送（MOV reg/mem,seg）</h3><p>例：MOV [SI],DS</p>
<p>​        MOV AX,ES</p>
<p>​        MOV DS,AX</p>
<p>上述两个语句可以实现从<strong>一个段到另一个段的传送（通过寄存器中转）</strong></p>
<p>总结：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="MOV总结.png" alt=""></p>
<h3 id="五-非法传送实例"><a href="#五-非法传送实例" class="headerlink" title="(五)非法传送实例"></a>(五)非法传送实例</h3><h4 id="1-两个操作数的类型不一致"><a href="#1-两个操作数的类型不一致" class="headerlink" title="1.两个操作数的类型不一致"></a>1.两个操作数的类型不一致</h4><p>绝大多数双操作数指令，除非特别说明，目的操作数与源操作数必须类型一致，否则为非法指令</p>
<p><strong>MOV AL,050AH ；非法指令：050Ah为字，而AL为字节</strong></p>
<p>对于存储器单元与立即数同时作为操作数的情况，必须<strong>显式指明</strong>；byte ptr指示字节类型，word ptr指示字类型</p>
<p><strong>MOV BYTE PTR [SI],0AH (字节操作)</strong></p>
<p><strong>MOV WORD PTR [SI+2],0BH(字操作)</strong></p>
<h4 id="2-两个操作数不能都是存储器"><a href="#2-两个操作数不能都是存储器" class="headerlink" title="2.两个操作数不能都是存储器"></a>2.两个操作数不能都是存储器</h4><p>存储器之间的传送，可以通过<strong>寄存器中转</strong>实现</p>
<p>MOV AX,BUFFER1</p>
<p>MOV BUFFER2,AX</p>
<h4 id="3-段寄存器的操作有一些限制"><a href="#3-段寄存器的操作有一些限制" class="headerlink" title="3.段寄存器的操作有一些限制"></a>3.段寄存器的操作有一些限制</h4><p>段寄存器属<strong>专用寄存器</strong>，对他们的操作能力有限</p>
<p><strong>不允许立即数传送给段寄存器</strong></p>
<p>MOV DS,100H；非法指令：立即数不能传送段寄存器</p>
<p><strong>不允许直接改变CS值</strong></p>
<p><strong>MOV CS,[SI] ；不允许使用的指令</strong></p>
<p>不允许<strong>段寄存器之间的直接数据传送</strong></p>
<p>MOV DS,ES；非法指令：不允许段寄存器间传送</p>
<p>​        MOV AX,ES</p>
<p>​        MOV DS,AX</p>
<p>上述两个语句可以实现从<strong>一个段到另一个段的传送（通过寄存器中转）</strong></p>
<h2 id="十、堆栈"><a href="#十、堆栈" class="headerlink" title="十、堆栈"></a>十、堆栈</h2><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="堆栈.png" alt=""></p>
<p>注意：</p>
<ol>
<li><strong>堆栈操作的单位是字</strong>，进栈和出栈只对字量</li>
<li>字量数据从栈顶压入和弹出时，都是<strong>低地址字节送低字节，高地址字节送高字节</strong></li>
<li>在pop指令中，<strong>POP CS 为非法指令</strong></li>
<li>堆栈操作不影响标志</li>
</ol>
<h2 id="十一、标志寄存器"><a href="#十一、标志寄存器" class="headerlink" title="十一、标志寄存器"></a>十一、标志寄存器</h2><p>标志（Flag）用于反映指令执行结果或控制指令执行形式。</p>
<p>8086中，各种常用的标志形成<strong>16位标志寄存器FLAGS</strong>（程序状态字PSW寄存器）分成两类：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="标志寄存器.png" alt=""></p>
<p>(1) 状态标志</p>
<p>状态标志是最基本的标志，用来记录指令执行结果的辅助信息。加、减运算和逻辑运算指令是主要设置他们的指令，有些其他指令的执行也会相应地设置它们。</p>
<h3 id="①进位标志CF（Carry-Flag）"><a href="#①进位标志CF（Carry-Flag）" class="headerlink" title="①进位标志CF（Carry Flag）"></a><strong>①进位标志CF（Carry Flag）</strong></h3><p>当运算结果的最高有效位<strong>有进位（加法）或借位</strong>（减法）时，进位标志置1，即<strong>CF = 1</strong>；否则CF = 0。</p>
<p>例：AAH + 7CH＝（1）26H，有进位：CF = 1</p>
<h3 id="②溢出标志OF（Overflow-Flag）"><a href="#②溢出标志OF（Overflow-Flag）" class="headerlink" title="②溢出标志OF（Overflow Flag）"></a><strong>②溢出标志OF（Overflow Flag）</strong></h3><p>若算术运算的结果<strong>有溢出</strong>，则<strong>OF＝1</strong>；否则 OF＝0</p>
<p>例：3AH+ 7CH＝B6H，就是58＋124＝182，超出了+127~-128范围。</p>
<p>产生溢出：OF = 1</p>
<h4 id="重点：什么是溢出？"><a href="#重点：什么是溢出？" class="headerlink" title="重点：什么是溢出？"></a>重点：什么是溢出？</h4><p>处理器内部<strong>以补码表示有符号数</strong></p>
<p>8位表达的整数范围是：<strong>＋127～－128</strong></p>
<p>16位表达的范围是：<strong>＋32767～－32768</strong></p>
<p>如果运算结果超出这个范围，就产生了溢出。有溢出，说明有符号数的运算结果不正确</p>
<h4 id="溢出和进位有什么区别？"><a href="#溢出和进位有什么区别？" class="headerlink" title="溢出和进位有什么区别？"></a>溢出和进位有什么区别？</h4><p>进位标志表示<strong>无符号数</strong>运算结果是否超出范围，<strong>超出范围后加上进位或借位运算结果仍然正确</strong></p>
<p>溢出标志表示<strong>有符号数</strong>运算结果是否超出范围，<strong>超出范围后运算结果不正确</strong>。</p>
<h4 id="如何判断溢出？"><a href="#如何判断溢出？" class="headerlink" title="如何判断溢出？"></a>如何判断溢出？</h4><p>只有当<strong>两个相同符号数相加</strong>（包括不同符号数相减），而<strong>运算结果的符号与原数据符号相反</strong>时，产生溢出；因为，此时的运算结果显然不正确</p>
<p><strong>其他情况下，则不会产生溢出</strong></p>
<p>奇偶标志PF（Parity Flag）</p>
<p><strong>1的个数为偶数时，PF=1，奇数为0</strong></p>
<p>仅反映最低8位中“1”的个数是偶或奇，即使是进行16位字操作</p>
<p>例：3AH + 7CH＝B6H＝10110110B  结果中有5个1，是奇数：PF = 0</p>
<p>零标志ZF（Zero Flag）</p>
<p><strong>运算结果为0，则ZF=1</strong></p>
<p>符号标志SF（Sign Flag）</p>
<p><strong>运算结果最高位为1，则SF = 1；否则SF = 0</strong></p>
<p>例：3AH + 7CH＝B6H，最高位D7＝1：SF = 1</p>
<p>​        84H + 7CH＝（1）00H，最高位D7＝0：SF = 0</p>
<p>(2) 控制标志</p>
<p>控制标志可由程序根据需要用指令设置，用于控制处理器执行指令的方式</p>
<p><strong>方向标志DF（Direction Flag）仅用于串操作指令中</strong>。</p>
<p>中断允许标志IF（Interruptenable Flag）简称中断标志。</p>
<p>若IF=1，则CPU可以相应外部可屏蔽中断请求</p>
<p>若IF=0，则CPU不允许相应中断请求。</p>
<p>陷阱标志TF（Trap Flag），常称为单步标志。</p>
<p>3.指令指针寄存器（Instruction Pointer）</p>
<p>IP是<strong>专用寄存器</strong>，具有自动增量的能力。处理器执行完一条指令，IP中的值就加上该指令的字节数，从而指向下一条指令。即：<strong>指示代码段中指令的偏移地址</strong>。</p>
<p>•<strong>它与代码段寄存器CS联用，确定下一条指令的物理地址</strong></p>
<p>•计算机通过CS : IP寄存器来控制指令序列的执行流程</p>
<h2 id="十二、物理地址和逻辑地址"><a href="#十二、物理地址和逻辑地址" class="headerlink" title="十二、物理地址和逻辑地址"></a>十二、物理地址和逻辑地址</h2><p>每个物理存储单元有一个唯一的<strong>20位编号，即物理地址</strong>：</p>
<p> 00000H～FFFFFH</p>
<p>•分段后用户编程时，采用<strong>逻辑地址：</strong></p>
<p>   <strong>段基地址 : 段内偏移地址</strong></p>
<p>段地址说明逻辑段在主存中的起始位置，8086规定段地址必须是模16地址：xxxx0H</p>
<p>将逻辑地址中的段地址左移四位，加上偏移地址就得到物理地址。</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="地址转换.png" alt=""></p>
<h2 id="十三、8086的寻址方式"><a href="#十三、8086的寻址方式" class="headerlink" title="十三、8086的寻址方式"></a>十三、8086的寻址方式</h2><h3 id="（一）立即数寻址"><a href="#（一）立即数寻址" class="headerlink" title="（一）立即数寻址"></a>（一）立即数寻址</h3><p>立即数寻址方式常用来给寄存器赋值</p>
<p>例：MOV AX,0102H ;AX,&lt;-0102H</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="立即数.png" alt=""></p>
<h3 id="二-寄存器寻址"><a href="#二-寄存器寻址" class="headerlink" title="(二)寄存器寻址"></a>(二)寄存器寻址</h3><p> MOV AX,1234H ；AX←1234H</p>
<p> MOV BX,AX ；BX←AX</p>
<h3 id="（三）存储器寻址"><a href="#（三）存储器寻址" class="headerlink" title="（三）存储器寻址"></a>（三）存储器寻址</h3><h4 id="1-直接寻址方式"><a href="#1-直接寻址方式" class="headerlink" title="1.直接寻址方式"></a>1.直接寻址方式</h4><p>默认的段地址在DS段寄存器，可使用段超越前缀改变</p>
<p>MOV AX,ES:[2000H]（用ES改变）</p>
<h4 id="2-寄存器间接寻址"><a href="#2-寄存器间接寻址" class="headerlink" title="2.寄存器间接寻址"></a>2.寄存器间接寻址</h4><p>有效地址存放在基址寄存器BX或变址寄存器SI、DI中</p>
<p>默认的段地址在DS段寄存器，可使用段超越前缀改变</p>
<p>MOV AX,[SI]  ；AX←DS:[SI]</p>
<h4 id="3-寄存器相对寻址"><a href="#3-寄存器相对寻址" class="headerlink" title="3.寄存器相对寻址"></a>3.寄存器相对寻址</h4><p>段地址对应BX/SI/DI寄存器默认在DS，对应BP寄存器默认在SS；可用段超越前缀</p>
<p>MOV AX,[DI+06H]    ；AX←DS:[DI+06H]</p>
<p>MOV AX,[BP+06H]   ；AX←SS:[BP+06H]</p>
<h4 id="4-基址变址寻址方式"><a href="#4-基址变址寻址方式" class="headerlink" title="4.基址变址寻址方式"></a>4.基址变址寻址方式</h4><p>有效地址＝BX/BP＋SI/DI</p>
<p>段地址对应<strong>BX基址寄存器默认是DS</strong>，对应<strong>BP基址寄存器默认是SS</strong>；可用段超越前缀</p>
<p> MOV AX,[BX+SI]       ；AX←DS:[BX+SI]</p>
<p> MOV AX,[BP+DI]       ；AX←SS:[BP+DI]</p>
<p> MOV AX,DS:[BP+DI]    ；AX←DS:[BP+DI]</p>
<h4 id="5-相对基址变址寻址"><a href="#5-相对基址变址寻址" class="headerlink" title="5.相对基址变址寻址"></a>5.相对基址变址寻址</h4><p>有效地址＝BX/BP＋SI/DI＋8/16位位移量</p>
<p>MOV AX,[BX+SI+06H] ；AX←DS:[BX+SI+06H]</p>
<h3 id="（四）多种表示"><a href="#（四）多种表示" class="headerlink" title="（四）多种表示"></a>（四）多种表示</h3><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="多种表示.png" alt=""></p>
<h2 id="十四、各种指令"><a href="#十四、各种指令" class="headerlink" title="十四、各种指令"></a>十四、各种指令</h2><p>XCHG</p>
<p><strong>XCHG reg,reg/mem </strong></p>
<p><strong>不能在存储器与存储器之间对换数据</strong></p>
<p>XLAT 换码指令</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="XLAT.png" alt=""></p>
<p>LEA 有效地址传送指令</p>
<p>将<strong>存储器操作数</strong>的有效地址传送至指定的<strong>16位寄存器</strong>中</p>
<p>例：</p>
<p>MOV BX,0400H</p>
<p>MOV SI,3CH</p>
<p>LEA BX,[BX+SI+0F62H]</p>
<p>；BX＝0400H＋003CH＋0F62H＝139EH</p>
<p>ADD 加法/SUB 减法</p>
<p>将源与目的操作数相加/减，<strong>结果送到目的操作数</strong></p>
<p>ADD AL,BL </p>
<p>（ADD mem,imm/reg）</p>
<p><strong>ADD WORD PTR [BX+2],0F0F0H</strong></p>
<p>INC（increment）DEC（decrement）</p>
<p>注意：INC/DEC指令<strong>不影响进位CF标志</strong>，按定义设置其他状态标志</p>
<p><strong>主要用于对计数器和地址指针的调整</strong></p>
<p>求补指令NEG（negative）</p>
<p>NEG指令对操作数执行求补运算：用零减去操作数，然后结果返回操作数</p>
<p>求补运算也可以表达成：<strong>将操作数按位取反后加1</strong></p>
<p>NEG指令对标志的影响与用零作减法的SUB指令一样</p>
<p><strong>NEG reg/mem</strong></p>
<p>比较指令CMP（compare）</p>
<p>CMP指令将目的操作数减去源操作数，按照定义相应设置状态标志</p>
<p><strong>但结果不回送目的操作数</strong></p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="cmp.png" alt=""></p>
<p>乘法 MUL/IMUL</p>
<p>源操作数显式给出，隐含使用另一个操作数AX和DX</p>
<p>•字节量相乘：<strong>AL与r8/m8相乘</strong>，得到<strong>16位的结果，存入AX</strong></p>
<p>•字量相乘：AX与r16/m16相乘，得到<strong>32位的结果，其高字存入DX，低字存入AX</strong></p>
<p>•乘法指令如下影响OF和CF标志：</p>
<p>•MUL指令——若乘积的高一半（AH或DX）为0，则OF=CF=0；否则OF=CF=1</p>
<p>•IMUL指令——若乘积的高一半是低一半的符号扩展，则OF=CF=0；否则均为1</p>
<p>乘法指令对其他状态标志没有定义</p>
<p>除法 DIV IDIV</p>
<p>•除法指令的除数显式给出，隐含使用<strong>另一个操作数AX和DX作为被除数</strong></p>
<p>•字节量除法：<strong>AX除以r8/m8，8位商存入AL，8位余数存入AH</strong></p>
<p>•字量除法：DX.AX除以r16/m16，16位商存入AX，16位余数存入DX</p>
<p>•除法指令对标志没有定义</p>
<p>除法指令会<strong>产生结果溢出</strong></p>
<p>•当被除数远大于除数时，所得的商就有可能超出它所能表达的范围。如果存放商的寄存器AL/AX不能表达，便产生溢出，8086CPU中就产生编号为0的内部中断——除法错中断</p>
<p>CBW/CWD</p>
<p>•<strong>对有符号数除法，可以利用符号扩展指令得到倍长于除数的被除数</strong></p>
<p>•<strong>对无符号数除法，采用直接使高8位或高16位清0，获得倍长的被除数。这就是零位扩展</strong></p>
<p>TEST与CMP</p>
<p>TEST<strong>不影响目的操作数</strong>，只根据运算结果设置标志。</p>
<p>test<strong>逻辑与（AND）运算结果为零</strong>,就把ZF(零标志)置1;<br>cmp <strong>算术减法运算（SUB）结果为零</strong>,就把ZF(零标志)置1.</p>
<p>NOT 逻辑非（按位取反）</p>
<p><strong>NOT  reg/mem</strong>    <strong>不影响任何标志。</strong></p>
<p>SHL/SAL/SHR/SAR</p>
<p><strong>SHL reg/mem,1/CL逻辑左移，最高位进入CF，最低位补0</strong></p>
<p><strong>操作数左移一位，相当于乘2（对有符号数同理，只要OF=0，结果就对）。</strong></p>
<p><strong>③操作数逻辑右移（SHR）一位，相当于无符号数除以2；操作数算术右移（SAR）一位，相当于有符号数除以2。</strong></p>
<p>循环移位</p>
<p>RCL/RCR 带着CF位循环左右移 ROL/ROR 不带CF左右移</p>
<p><strong>RCL是将某数最高位移进入CF，而CF里的内容跑到该数的最低位，形成咬尾蛇循环，移位次数为CL或CX指定的次数</strong></p>
<p>例：将32位左移一位</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="32位左移.png" alt=""></p>
<h2 id="十五、控制转移类指令"><a href="#十五、控制转移类指令" class="headerlink" title="十五、控制转移类指令"></a>十五、控制转移类指令</h2><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="段内段间.png" alt=""></p>
<p>段内转移、间接寻址</p>
<p>JMP R16/M16  ；IP←R16/M16</p>
<p><strong>JMP WORD PTR [2000H] ；IP←[2000H]</strong> </p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="段间.png" alt=""></p>
<p>段间转移、直接寻址</p>
<p>JMP FAR PTR LABEL</p>
<p> ；IP←LABEL的偏移地址</p>
<p> ；CS←LABEL的段地址</p>
<p>段间转移、间接寻址</p>
<p>JMP FAR PTR MEM</p>
<p> ；IP←[MEM]，CS←[MEM+2]</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="大小关系.png" alt=""></p>
<h2 id="十六、大小与高低"><a href="#十六、大小与高低" class="headerlink" title="十六、大小与高低"></a>十六、大小与高低</h2><p>•<strong>无符号数</strong>的大小用<strong>高（Above）低</strong>（<strong>Below</strong>）表示</p>
<p>•利用<strong>CF确定高低、利用ZF标志确定相等</strong>（Equal）</p>
<p>•两数的高低分成4种关系：</p>
<p>⑴ 低于（不高于等于）：JB（JNAE）</p>
<p>⑵ 不低于（高于等于）：JNB（JAE）</p>
<p>⑶ 低于等于（不高于）：JBE（JNA）</p>
<p>⑷ 不低于等于（高于）：JNBE（JA ）</p>
<p><strong>•有符号数</strong>的<strong>大（Greater）小（Less）</strong></p>
<p>需要组合<strong>OF、SF</strong>标志，并<strong>利用ZF标志确定相等</strong>（Equal）</p>
<p>•两数的大小分成4种关系：</p>
<p>⑴ 小于（不大于等于）：JL（JNGE）</p>
<p>⑵ 不小于（大于等于）：JNL（JGE）</p>
<p>⑶ 小于等于（不大于）：JLE（JNG）</p>
<p>⑷ 不小于等于（大于）：JNLE（JG ）</p>
<p><strong>JCXZ</strong>    <strong>（</strong> <strong>CX=0**</strong>）  串操作是否处理完所有**   </p>
<p>LOOP label  CX!=0 循环label</p>
<p>LOOPZ label CX!=0且ZF=1 循环label</p>
<p>•<strong>循环指令默认利用CX计数器</strong></p>
<p>•<strong>label操作数采用相对短转移寻址方式</strong></p>
<p><strong>空操作指令 NOP</strong></p>
<p>不执行任何操作，但占用一个字节存储单元，空耗一个指令执行周期</p>
<p>作用：<strong>预留空间 删除指令 软件延时</strong></p>
<p>•事实上，NOP和XCHG AX,AX的指令代码一样，都是 90H</p>
<p>ORG参数（使他后面的数据或指令从参数指定的地址开始）</p>
<p>ORG 100H；从0100H单元开始分配存储器。</p>
<p> <strong>ORG $+10；$表示地址计数器的当前值，$+10</strong></p>
<p><strong>表示由当前地址向前跳过10个字节。</strong></p>
<p>•EVEN ;从偶地址开始</p>
<p>•ALIGN n ;从n的整数倍地址开始</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="定位伪指令.png" alt=""></p>
<h2 id="十七、地址操作符和类型操作符"><a href="#十七、地址操作符和类型操作符" class="headerlink" title="十七、地址操作符和类型操作符"></a>十七、地址操作符和类型操作符</h2><h3 id="（一）地址操作符"><a href="#（一）地址操作符" class="headerlink" title="（一）地址操作符"></a>（一）地址操作符</h3><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="地址操作符.png" alt=""></p>
<p><code>mov bx,offset array  ;等价于 lea bx,array</code></p>
<p> <code>mov cl,array+4          ;等效于 mov cl,array[4]</code></p>
<h3 id="（二）类型操作符"><a href="#（二）类型操作符" class="headerlink" title="（二）类型操作符"></a>（二）类型操作符</h3><p>PTR操作符：使名字或标号具有指定的类型</p>
<p><code>mov al,byte ptr w_var ;w_var是一个字变量</code></p>
<p><code>jmp far ptr n_label ;n_label是一个标号</code></p>
<p>THIS</p>
<p>•利用THIS说明的操作数具有汇编时的当前逻辑地址，但具有指定的类型</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="THIS.png" alt=""></p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line">.model small</span><br><span class="line">	   .stack</span><br><span class="line">	   .data</span><br><span class="line">V_byte  equ this byte</span><br><span class="line">V_word  dw 3332h,3735h</span><br><span class="line">Target  dw 5 dup(20h)</span><br><span class="line">Crlf    db 0dh,0ah, ‘<span class="formula">$’</span></span><br><span class="line"><span class="formula">Flag    db 0</span></span><br><span class="line"><span class="formula">N_point dw offset s_label</span></span><br><span class="line"><span class="formula">	   .code</span></span><br><span class="line"><span class="formula">	   .startup</span></span><br><span class="line"><span class="formula">	   mov al,byte ptr v_word</span></span><br><span class="line"><span class="formula">	   dec al</span></span><br><span class="line"><span class="formula">	   mov  v_byte ,al;v_word=3331h	</span></span><br><span class="line"><span class="formula">	   N_label:cmp flag,1 ;flag单元=0</span></span><br><span class="line"><span class="formula">	    jz s_label</span></span><br><span class="line"><span class="formula">	    inc flag  ；flag=1</span></span><br><span class="line"><span class="formula">	    jmp short n_label</span></span><br><span class="line"><span class="formula">S_label: cmp flag,2  ;flag=1</span></span><br><span class="line"><span class="formula">	    jz next</span></span><br><span class="line"><span class="formula">	    inc flag   ;flag=2</span></span><br><span class="line"><span class="formula">    jmp n_point ;段内间接转移，等同于jmp s_label</span></span><br><span class="line"><span class="formula">Next: mov ax,type v_word  ;ax=0002h</span></span><br><span class="line"><span class="formula">	    mov cx,lengthof target;5个数据项，cx=5</span></span><br><span class="line"><span class="formula">	    mov si,offset target</span></span><br><span class="line"><span class="formula">W_again: mov [si],ax</span></span><br><span class="line"><span class="formula">	    inc si</span></span><br><span class="line"><span class="formula">	    inc si</span></span><br><span class="line"><span class="formula">      loop w_again;对target填充5个字：0002h</span></span><br><span class="line"><span class="formula">mov cx,sizeof target;cx=10</span></span><br><span class="line"><span class="formula">	    mov al,’?’</span></span><br><span class="line"><span class="formula">	    mov di,offset target</span></span><br><span class="line"><span class="formula">B_again: mov [di],al</span></span><br><span class="line"><span class="formula">	    inc di</span></span><br><span class="line"><span class="formula">	    loop b_again ;对target填充10个‘？’</span></span><br><span class="line"><span class="formula">	    mov dx,offset v_word</span></span><br><span class="line"><span class="formula">	    mov ah,9</span></span><br><span class="line"><span class="formula">	    int 21h  ;显示结果为1357??????????</span></span><br><span class="line"><span class="formula">	    .exit 0</span></span><br><span class="line"><span class="formula">	    end</span></span><br></pre></td></tr></table></figure>
<h2 id="十八、简化段定义标准格式"><a href="#十八、简化段定义标准格式" class="headerlink" title="十八、简化段定义标准格式"></a>十八、简化段定义标准格式</h2><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="简化段.png" alt=""></p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>只花了一天的时间去复习整理汇编语言，希望别挂科就好</p>
<p>后面看到这篇的人一定要好好学汇编啊。</p>
<p>张海英你没有心（确信）</p>
]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
      <tags>
        <tag>课内学习笔记</tag>
        <tag>考试复习整理</tag>
      </tags>
  </entry>
  <entry>
    <title>紫罗兰永恒花园观后感</title>
    <url>/2021/01/12/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD%E8%A7%82%E5%90%8E%E6%84%9F/</url>
    <content><![CDATA[<p>一直被人安利的京紫，终于在今天追完了，现在内心还是有点不能平静。</p>
<p>上一个正正经经追的番还是《魔卡少女樱》，那是对童年的追忆和怀念。</p>
<p>这部番，值得我写一篇文来纪念其上映三周年：2018.1.11~2020.1.12</p>
<h2 id="矛盾"><a href="#矛盾" class="headerlink" title="矛盾"></a>矛盾</h2><p>以前的我，最不能理解的就是<strong>自我矛盾</strong>，正如前几集艾丽卡认为Violet不能胜任人偶的工作，却仍然力保她留在公司时，Violet发出的疑问，以前的我也常常有这种想法，觉得人总是心口不一，遇到矛盾的事就嗤之以鼻。</p>
<p>但这部番从各种矛盾入手，对Violet进行了全面的人格塑造：14岁的少女与杀人机器、断送他人的性命与撰写替人结缘的书信，冷冰冰的人偶与不需要指令的”人“。一个个矛盾交织在一起，对每个关键点都有合适的flashback，将故事连贯起来，是我最喜欢的一个方面。</p>
<h2 id="战争"><a href="#战争" class="headerlink" title="战争"></a>战争</h2><p>看到B站评论中有一句：”本来就是写战争的还硬洗，既然知道战争的残酷与无情，当初还发动战争，有点既当了**还想立牌坊的感觉”。诚然，战争是本番的一条主线，也正是战争将violet变成了这副模样。每集中都或多或少带有战争的元素：Violet失去了少佐后救赎了自己；未能保护好边线的士兵从自我沉沦中重生；待不到男友返乡的歌剧演员以一首情书彻底解冻时间线，每一个故事都反映出了战争的残忍，但只有战争才能避免更多的悲伤分别发生，EX集中那个归乡士兵的特写，人们在火车站的寻人启事墙上自发点起了蜡烛为他们祈福的举动，既让Violet得到感染，更让我体会到了离别后的振作之情。</p>
<h2 id="信"><a href="#信" class="headerlink" title="信"></a>信</h2><p>信，则是全番中的另一个主线，从想要理解<strong>”我爱你“</strong>的含义而称为人偶，通过一系列的工作经历，violet不断懂得了那些她当兵时未曾体会到的情感，她懂得了如何去感受人的想法，做到”共情“，从一封封信的写作中，Violet也从之前那个只会写报告书的军人，变成了一个，她写给少佐的信躺在了丛中，也躺在了我心里。</p>
<p>我也一直有写信的习惯，那些文字，通过纸笔变成了一个个心意，那是语言所无法表达的独特，只能通过”见信如面“和”XXX亲启“来传递的唯一，是不可替代的。</p>
<p>看别人玩你画我猜的时候，有人在题目是这个番时只画了一封信，当时的我还不明白为什么，但现在我觉得，那封信就能代表一切，它是本番的<strong>灵魂所在</strong>。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>你们可能觉得我前面没有说这部番的画功怎么样，这么给你说，刚才举报了一个”因为画质高看得眼睛酸所以差评”的一星评论，懂了吧（</p>
<p>漫画里最后Violet和少佐重逢了，算是一个HE，但我更喜欢动漫中的结局，少女带着全新的希望奔赴未来</p>
<p>没有放图的原因是，看的很认真没有截图，而且每一帧都值得我去收藏，我就只存了几个自己喜欢的画面。</p>
<div class="note primary no-icon flat">
    <p>
        希望大家多多给我推荐类似这种的优质番，俺在线拜谢你们（
    </p>
    <p>也希望我明白”爱“的意义的那天早日到来</p>
</div>



<p>最后，对于熬夜，薇酱这句话我觉得很有道理。</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="熬夜.png" alt=""></p>
<p>大家还是少熬夜，养生作息早睡早起它不香🐎？</p>
<p>ps：有一说一日本人直接拿英文来起名字还挺好听的（Violet Evergarden)。感觉翻译成中文总差点感觉，就用英文打了。</p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
  </entry>
  <entry>
    <title>假期每日总结</title>
    <url>/2021/01/11/%E5%81%87%E6%9C%9F%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="2020-01-11"><a href="#2020-01-11" class="headerlink" title="2020-01-11"></a>2020-01-11</h2><div class="note success no-icon flat">
                            <p>
                                <strong>编程⭐</strong>
                            </p>
                            <table>
                                <thead>
                                    </thead>
                            <tbody>
                                <tr>
                                    <td>
                                        在VSCODE上配置了java运行环境
                                    </td>
                                    <td>
                                        参考网址：<a href="https://www.cnblogs.com/bpf-1024/p/13375253.html">vscode 配置 Java 环境</a>
                                    </td>
                                                                    </tr>
                                 <tr>
                                    <td>
                                        安装并激活了用于JAVA的IDEA
                                    </td>
                                    <td>
                                        参考网址：<a href="https://www.jb51.net/softs/543014.html">IDEA 2020.3.1激活汉化</a>
                                    </td>
                                                                    </tr>
                        </tbody>
                    </table>
                </div>                              
  <div class="note info no-icon flat">
                            <p>
                                <strong>读书⭐</strong>
                            </p>
                            <table>
                                <thead>
                                    <tr>
                                        <th>书名</th>
                                        <th>进度</th>
                                    </tr>
                                    </thead>
                            <tbody>
                                <tr>
                                    <td align="center">
                                        <a href="https://book.douban.com/subject/10785583/">思考快与慢</a>
                                    </td>
                                    <td align="center">20-34页</td></tr>
                                <tr>
                                                                </tr>
                             </tr>
                </tbody>
            </table>
        </div>



<div class="note warning no-icon flat">
                            <p>
                                <strong>杂项⭐</strong>
                            </p>
                            <table>
                                <thead>
                                    <tr>
                                                                        </tr>
                                </thead>
                        <tbody>
                            <tr>
                                <td>
                                   吃到了回家的第一碗牛肉面！
                                </td>
                             </tr>
                                <tr>
                                <td>
                                   整理了大二上的相关资料
                                </td>
                                                                </tr>
                             </tr>
                </tbody>
            </table>
        </div>


  <div class="note info default no-icon flat">
                            <p>
                                <strong>番剧⭐</strong>
                            </p>
                            <table>
                                <thead>
                                    <tr>
                                        <th>剧名</th>
                                        <th>进度</th>
                                    </tr>
                                    </thead>
                            <tbody>
                                <tr>
                                    <td align="center">
                                        <a href="https://www.bilibili.com/bangumi/play/ss21542/?from=search&seid=3279280140502349102">紫罗兰永恒花园</a>
                                    </td>
                                    <td align="center">
                                        1-6集
                                    </td>
                                 </tr>
                                </tr>
                </tbody>
            </table>
        </div>            


<div class="note primary no-icon flat">
                            <p>
                                <strong>今日所得⭐</strong>
                            </p>
                            <table>
                                <thead>
                                    </thead>
                            <tbody>
                                <tr>
                                    <td>
                                        如何在HTML中构造表格
                                    </td>
                                    <td>
                                        参考网址：<a href="http://c.biancheng.net/view/7540.html">HTMLtable标签（表格）</a>
                                    </td>
                                                                    </tr>
                        </tbody>
                    </table>
                </div>                                


<h2 id="2020-01-12"><a href="#2020-01-12" class="headerlink" title="2020-01-12"></a>2020-01-12</h2><div class="note info default no-icon flat">
                            <p>
                                <strong>番剧⭐</strong>
                            </p>
                            <table>
                                <thead>
                                    <tr>
                                        <th>剧名</th>
                                        <th>进度</th>
                                        <th>观后感</th>
                                    </tr>
                                    </thead>
                            <tbody>
                                <tr>
                                    <td align="center">
                                        <a href="https://www.bilibili.com/bangumi/play/ss21542/?from=search&seid=3279280140502349102">紫罗兰永恒花园</a>
                                    </td>
                                    <td align="center">7-13集
                                                                        </td>
                                    <td align="center">
                                        <a href="/2021/01/12/紫罗兰永恒花园观后感/">紫罗兰永恒花园观后感</a>
                                    </td>
                             </tr>
                            </tr>
            </tbody>
        </table>
    </div>            



<h2 id="2020-01-13"><a href="#2020-01-13" class="headerlink" title="2020-01-13"></a>2020-01-13</h2><div class="note success no-icon flat">
                            <p>
                                <strong>美赛⭐</strong>
                            </p>
                            <table>
                                <thead>
                                    </thead>
                            <tbody>
                                <tr>
                                    <td>
                                        找到了很好的论文模板
                                    </td>
                                    <td>
                                        参考网址：<a >诶就不给你看</a>
                                    </td>
                                                                    </tr>
                                 <tr>
                                    <td>
                                        整理了一些C题论文，希望明天能看一点，希望能看懂
                                    </td>
                                                                    </tr>
                        </tbody>
                    </table>
                </div>                 

<div class="note warning no-icon flat">
                            <p>
                                <strong>杂项⭐</strong>
                            </p>
                            <table>
                                <thead>
                                    <tr>
                                                                        </tr>
                                </thead>
                        <tbody>
                            <tr>
                                <td>
                                   去书店买了喜欢的四本书：《病隙碎笔》 《红与黑》 《瓦尔登湖》 《漫长的告别》（最后一本是突然发现的）
                                </td>
                             </tr>
                                <tr>
                                <td>
                                   晚上罪恶地去打了LOL（还输了好多场气死我了）
                                </td>
                                                                </tr>
                            <tr>
                                <td>
                                   加了Java和数据库的QQ群，还有计组毛概军理多媒体的没加呢
                                </td>
                                                                </tr>
                             </tr>
                </tbody>
            </table>
        </div>

<p>今天玩的太多了，明天一定好好学习呜呜呜呜呜</p>
<h2 id="2020-01-14"><a href="#2020-01-14" class="headerlink" title="2020-01-14"></a>2020-01-14</h2><div class="note success no-icon flat">
                            <p>
                                <strong>美赛⭐</strong>
                            </p>
                            <table>
                                <thead>
                                    </thead>
                            <tbody>
                                <tr>
                                    <td>
                                        改了模板目录的一些瑕疵
                                    </td>
                                                                    </tr>
                                <tr>
                                    <td>
                                        找到了比MathType好的公式编辑器！<a href="https://www.amyxun.com/">AxMath</a>
                                    </td>
                                                                    </tr>
                                 <tr>
                                    <td>
                                        整理了一些C题论文，希望明天能看一点，希望能看懂
                                    </td>
                                                                    </tr>
                        </tbody>
                    </table>
                </div>                 
<div class="note warning no-icon flat">
                            <p>
                                <strong>杂项⭐</strong>
                            </p>
                            <table>
                                <thead>
                                    <tr>
                                                                        </tr>
                                </thead>
                        <tbody>
                            <tr>
                                <td>
                                   换了一直忘了换的Google头像
                                </td>
                             </tr>
                                <tr>
                                <td>
                                   晚上又罪恶地打了LOL
                                </td>
                                                                </tr>
                            <tr>
                                <td>
                                   美编接了一口大锅
                                </td>
                                                                </tr>
                             </tr>
                </tbody>
            </table>
        </div>

<h2 id="2020-01-15"><a href="#2020-01-15" class="headerlink" title="2020-01-15"></a>2020-01-15</h2><div class="note warning no-icon flat">
                            <p>
                                <strong>杂项⭐</strong>
                            </p>
                            <table>
                                <thead>
                                    <tr>
                                                                        </tr>
                                </thead>
                        <tbody>
                            <tr>
                                <td>
                                    分工让干事们去做四史的四格漫画，搞定了剧本
                                </td>
                             </tr>
                                <tr>
                                <td>
                                    晚上依然打了LOL
                                </td>
                                                                </tr>
                             </tr>
                </tbody>
            </table>
        </div>

<p>今天怎么只干了杂项啊，摸鱼太多了，不行不行。</p>
<h2 id="2020-01-16"><a href="#2020-01-16" class="headerlink" title="2020-01-16"></a>2020-01-16</h2><div class="note success no-icon flat">
                            <p>
                                <strong>美赛⭐</strong>
                            </p>
                            <table>
                                <thead>
                                    </thead>
                            <tbody>
                                <tr>
                                    <td>
                                        找到了美赛花里胡哨做图神器！<a href="https://www.ghpym.com/edrawmax.html/comment-page-1">亿图</a>
                                    </td>
                                                                    </tr>
                                 <tr>
                                    <td>
                                        看了一些论文的大致框架，明天看前面国赛的细致讲解
                                    </td>
                                                                    </tr>
                        </tbody>
                    </table>
                </div>      

<div class="note success no-icon flat">
                            <p>
                                <strong>编程⭐</strong>
                            </p>
                            <table>
                                <thead>
                                    </thead>
                            <tbody>
                                <tr>
                                    <td>
                                        帮朋友打了一场牛客网比赛（指签到） 感谢ljl的大力奉献（磕头）
                                    </td>
                                    <td>
                                        比赛网址：<a href="https://ac.nowcoder.com/acm/contest/11290?&headNav=www">西北工业大学编程之星设计挑战赛</a>
                                    </td>
                                                                    </tr>
                        </tbody>
                    </table>
                </div>       
<div class="note warning no-icon flat">
                            <p>
                                <strong>杂项⭐</strong>
                            </p>
                            <table>
                                <thead>
                                    <tr>
                                                                        </tr>
                                </thead>
                        <tbody>
                            <tr>
                                <td>
                                   终于换了网站的头像，泪目。以后估计会长期使用这个头像了（QQ也换成这个了）
                                </td>
                             </tr>
                                <tr>
                                <td>
                                   晚上又罪恶地打了LOL
                                </td>
                                                                </tr>
                            <tr>
                                <td>
                                   漫画进入上色收尾环节
                                </td>
                                                                </tr>
                             </tr>
                </tbody>
            </table>
        </div>

<h2 id="2020-01-17"><a href="#2020-01-17" class="headerlink" title="2020-01-17"></a>2020-01-17</h2><div class="note warning no-icon flat">
                            <p>
                                <strong>杂项⭐</strong>
                            </p>
                            <table>
                                <thead>
                                    <tr>
                                                                        </tr>
                                </thead>
                        <tbody>
                            <tr>
                                <td>
                                   今天终于监工着把东西交了，时间紧张，但出的东西还是很好的
                                </td>
                             </tr>
                            <tr>
                                <td>
                                   吃了回家的第一份外卖：炒粉
                                </td>
                                                                </tr>
                                <tr>
                                <td>
                                   把下学期的课表导入了日历中
                                </td>
                                                                </tr>
                             </tr>
                </tbody>
            </table>
        </div>

<div class="note info no-icon flat">
                            <p>
                                <strong>读书⭐</strong>
                            </p>
                            <table>
                                <thead>
                                    <tr>
                                        <th>书名</th>
                                        <th>进度</th>
                                    </tr>
                                    </thead>
                            <tbody>
                                <tr>
                                    <td align="center">
                                        <a href="https://book.douban.com/subject/10785583/">思考快与慢</a>
                                    </td>
                                    <td align="center"></td>
                                </tr>
                                <tr>
                                    <td align="center">
                                        <a href="https://book.douban.com/subject/3013903/">漫长的告别</a>
                                    </td>
                                    <td align="center"></td>
                                </tr>
                             </tr>
                </tbody>
            </table>
        </div>

<div class="note primary no-icon flat">
                            <p>
                                <strong>今日所得⭐</strong>
                            </p>
                            <table>
                                <thead>
                                    </thead>
                            <tbody>
                                <tr>
                                    <td>
                                        如何在IOS日历中构造课程表
                                    </td>
                                    <td>
                                        参考网址：<a href="https://www.zhihu.com/question/420075512">怎么把课表导入苹果日历中？</a>
                                    </td>
                                                                    </tr>
                        </tbody>
                    </table>
                </div>                 
## 一周总结：01-11 ~01-17

这周在网站的完善上面花了挺多功夫

## 2020-01-18


今天纯划水了，感觉到了带着小孩做工作的艰辛，以后我得唱白脸了（确信

## 2020-01-19

<div class="note warning no-icon flat">
                            <p>
                                <strong>杂项⭐</strong>
                            </p>
                            <table>
                                <thead>
                                    <tr>
                                                                        </tr>
                                </thead>
                        <tbody>
                            <tr>
                                <td>
                                   进行了学院的校庆志愿者面试
                                </td>
                             </tr>
                            <tr>
                                <td>
                                   下午去吃烤肉！
                                </td>
                                                                </tr>
                                <tr>
                                <td>找齐了下学期所用的电子书，芜湖</td>
                                                            </tr>
                            <tr>
                                <td>LOL日常血C，AD现状了</td>
                                                            </tr>
                         </tr>
            </tbody>
        </table>
    </div>     


<h2 id="2020-01-20"><a href="#2020-01-20" class="headerlink" title="2020-01-20"></a>2020-01-20</h2><div class="note success no-icon flat">
                            <p>
                                <strong>美赛⭐</strong>
                            </p>
                            <table>
                                <thead>
                                    </thead>
                            <tbody>
                                <tr>
                                    <td>
                                        看了篇比较详细的美赛分享 
                                    <td align="center">视频链接：<a href="https://www.bilibili.com/video/BV1Xz4y1U78b">西电数模美赛O奖分享交流</a></td>
                                    </td>
                                                                    </tr>
                        </tbody>
                    </table>
                </div>      
<div class="note warning no-icon flat">
                            <p>
                                <strong>杂项⭐</strong>
                            </p>
                            <table>
                                <thead>
                                    <tr>
                                                                        </tr>
                                </thead>
                        <tbody>
                            <tr>
                                <td>
                                   探索了一下用VPN进学校数据库的方法
                                </td>
                             </tr>
                            <tr>
                                <td>
                                   9.8升级了守望典藏版，芜湖！
                                </td>
                                                                </tr>
                                <tr>
                                <td>大概整理了一下大学目前用到过的电子书，可以当书贩子了）</td>
                                                            </tr>
                            <tr>
                                <td>LOL日常血C</td>
                                                            </tr>
                         </tr>
            </tbody>
        </table>
    </div> 

<p>打算开一个新坑，记录自己看着眼熟但一直不会的单词（希望能坚持一下）</p>
<p>今天看lili为了工作熬了三天夜，瞬间想口吐芬芳惹。明天开会要好好说一下这个问题，在线锤人</p>
<h2 id="2020-01-21"><a href="#2020-01-21" class="headerlink" title="2020-01-21"></a>2020-01-21</h2><div class="note success no-icon flat">
                            <p>
                                <strong>美赛⭐</strong>
                            </p>
                            <table>
                                <thead>
                                    </thead>
                            <tbody>
                                <tr>
                                    <td>
                                        继续看美赛论文写作
                                    </td>
                                                                    </tr>
                                <tr>
                                <td>将论文中翻英的软件大致定为了DeepL Pro，试了一下还可以</td>
                                                            </tr>
                        </tbody>
                    </table>
                </div>


<div class="note warning no-icon flat">
                            <p>
                                <strong>杂项⭐</strong>
                            </p>
                            <table>
                                <thead>
                                    <tr>
                                                                        </tr>
                                </thead>
                        <tbody>
                            <tr>
                                <td>
                                   回坑了摩尔庄园，还领了半年的超级拉姆，芜湖
                                </td>
                             </tr>
                            <tr>
                                <td>
                                   又接了新锅（大事记设计），估计得让他们自己发挥了
                                </td>
                                                                </tr>
                            <tr>
                                <td>LOL日常血C，不过今天只打了一把</td>
                                                            </tr>
                         </tr>
            </tbody>
        </table>
    </div> 



<h2 id="2020-01-22"><a href="#2020-01-22" class="headerlink" title="2020-01-22"></a>2020-01-22</h2><div class="note success no-icon flat">
                            <p>
                                <strong>美赛⭐</strong>
                            </p>
                            <table>
                                <thead>
                                    </thead>
                            <tbody>
                                <tr>
                                    <td>
                                        大概浏览完了《正确写作MCM论文》，感觉讲的都是一些用词的细节
                                    </td>
                                                                    </tr>
                        </tbody>
                    </table>
                </div>

<div class="note primary no-icon flat">
                            <p>
                                <strong>今日所得⭐</strong>
                            </p>
                            <table>
                                <thead>
                                    </thead>
                            <tbody>
                                <tr>
                                    <tr>
                                <td>终于把之前一直没改好的成绩检测器给配好并挂在电脑的计划任务了</td>
                                    <td >网上的源脚本（只支持python2.7，需要3.7版请联系我）<a href="https://smartjinyu.com/python/2017/01/14/xmu_gpa_monitor.html">XMU出分检测脚本</a> </td>
                                                            </tr>
                        </tbody>
                    </table>
                </div>  

<h2 id="2020-01-23"><a href="#2020-01-23" class="headerlink" title="2020-01-23"></a>2020-01-23</h2><div class="note warning no-icon flat">
                            <p>
                                <strong>杂项⭐</strong>
                            </p>
                            <table>
                                <thead>
                                    <tr>
                                                                        </tr>
                                </thead>
                        <tbody>
                            <tr>
                                <td>
                                   发了宣传宣讲的说说，建了群，还加了同济和南开的宣讲群
                                </td>
                             </tr>
                            <tr>
                                <td>
                                   获得了一些电子手账和单词本，打算从美赛后开始用
                                </td>
                                                                </tr>
                            <tr>
                                <td>LOL日常血C，最近中下都在玩，还是下路好玩（确信</td>
                                                            </tr>
                         </tr>
            </tbody>
        </table>
    </div> 



<h2 id="2020-01-24"><a href="#2020-01-24" class="headerlink" title="2020-01-24"></a>2020-01-24</h2><div class="note warning no-icon flat">
                            <p>
                                <strong>杂项⭐</strong>
                            </p>
                            <table>
                                <thead>
                                    <tr>
                                                                        </tr>
                                </thead>
                        <tbody>
                            <tr>
                                <td>
                                   看了些老师在群中发的资料，等会过来评论
                                </td>
                             </tr>
                            <tr>
                                <td>
                                   获得了一些电子手账和单词本，打算从美赛后开始用
                                </td>
                                                                </tr>
                            <tr>
                                <td>LOL日常血C，最近中下都在玩，还是下路好玩（确信</td>
                                                            </tr>
                         </tr>
            </tbody>
        </table>
    </div> 

<div class="note primary no-icon flat">
                            <p>
                                <strong>今日所得⭐</strong>
                            </p>
                            <table>
                                <thead>
                                    </thead>
                            <tbody>
                                <tr>
                                    <td>
                                        如何在获取网站的图标
                                    </td>
                                    <td>
                                        参考网址：<a href="https://jingyan.baidu.com/article/a3f121e4a46a79fc9152bb75.html">取得某个网站的图标</a>
                                    </td>
                                                                    </tr>
                        </tbody>
                    </table>
                </div>  

]]></content>
  </entry>
</search>
